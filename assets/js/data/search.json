[
  
  {
    "title": "Git - Tips and Tricks",
    "url": "/posts/Git-Tips-and-Tricks/",
    "categories": "GitHub, Git",
    "tags": "git, github, sourcecontrol",
    "date": "2023-10-01 00:00:00 +0200",
    





    
    "snippet": "GitHub is a internet hosting provider for software development and version control using git. It provides distributed version control, source code management, issue tracking and many more. This is ...",
    "content": "GitHub is a internet hosting provider for software development and version control using git. It provides distributed version control, source code management, issue tracking and many more. This is now the number one version control provider. Here, I will discuss on tips and tricks of gitDiscard unstaged changes in Git  For all unstaged files in current working directory usegit checkout -- Merge your local uncommited changesgit stash \t  git pull\t  git stash applyRemove cached files  Go to the directory and run the following commandgit rm -r --cached obj/Move git repository to another repository with historycd ngModule_repo    git remote rename origin old-origin    git remote add origin https://github.com/hbolajraf/ngModule.git    git push -u origin --all    git push -u origin --tagsUndo the commit, which has not been pushed yet  Check how many commitgit log        // Type q to exit this screen  Remove commit and keep file stagedgit reset --soft HEAD~1  Remove commit and unstaged filegit reset HEAD~1  Remove commit and discard changesgit reset --hard HEAD~1"
  },
  
  {
    "title": "Configure QoS within API Gateway using ocelot and Polly",
    "url": "/posts/Configure-QoS-within-API-Gateway-using-ocelot-and-Polly/",
    "categories": "Microservices, Ocelot",
    "tags": "microsoft, aspnetcore, csharp, microservices, ocelot, polly, webapi, c#, gateway, qos",
    "date": "2023-09-27 00:00:00 +0200",
    





    
    "snippet": "IntroductionAPI Gateway is an entry point for backend application. It maintains routing, authentication, logging, service discovery etc. Ocelot is used to design and develop API gateway for .net ba...",
    "content": "IntroductionAPI Gateway is an entry point for backend application. It maintains routing, authentication, logging, service discovery etc. Ocelot is used to design and develop API gateway for .net based application. QoS is generally configured in API gateway which provides different priorities for different applications, users or traffic. In this article, we will configure and discuss Quality of Services (QoS) using ocelot and Polly on ASP.NET Core web API project.What is Quality of Service (QoS)?QoS provides different priorities to different applications, users or data flow. We have already mentioned, Ocelot is used to design API Gateway and Ocelot uses Polly to achieve QoS.The QoSOptions node contains three important properties.      ExceptionsAllowedBeforeBreakingThis value must greater than 0. It means that the circuit breaker will break after a certain number of exceptions occur. For example:        DurationOfBreakThis value specifies how long the circuit breaker will stay open after it is tripped. The unit of this value is milliseconds. For example: 5000 means 5 seconds        TimeoutValueThis value specifies that a request will automatically be timed out if it takes more than this value. The unit of this value is milliseconds as well. For example: 3000 means 3 seconds.  Tools and Technology used  Visual Studio 2022  .NET 6.0  In Memory Database  Entity Framework  ASP.NET Core Web API  C#  Ocelot and  MMLib.SwaggerForOcelotImplementationStep 1: Create solution and projects.  Create a solution name QoS.  Add 2 new web api projects, name – Catalog.API, BFF.WebHere, BFF.Web project will act as API Gateway.Step 2: Install nuget packages.  Install following nuget packages in Catalog.API    PM&gt; Install-Package Microsoft.EntityFrameworkCore.InMemory    PM&gt; Install-Package Microsoft.EntityFrameworkCore.SqlServer    PM&gt; Install-Package Microsoft.EntityFrameworkCore.Tools    PM&gt; Install-Package Microsoft.VisualStudio.Web.CodeGeneration.Design      Install following nuget packages in BFF.Web    PM&gt; Install-Package MMLib.SwaggerForOcelot    PM&gt; Install-Package Ocelot    PM&gt; Install-Package Ocelot.Provider.PollyStep 3: Organize Catalog.API  Create CatalogItem model in Model folderCatalogItem.cs    using System.ComponentModel.DataAnnotations;    using System.ComponentModel.DataAnnotations.Schema;        namespace Catalog.API.Model    {        public class CatalogItem        {            [Key]            [DatabaseGenerated(DatabaseGeneratedOption.Identity)]            public int Id { get; set; }            public string Name { get; set; }                public string Description { get; set; }                public decimal Price { get; set; }                public int AvailableStock { get; set; }                public int RestockThreshold { get; set; }        }    }  Create DbContext class as CatalogContext in Db folderCatalogContext.cs    using Catalog.API.Model;    using Microsoft.EntityFrameworkCore;        namespace Catalog.API.Db    {        public class CatalogContext : DbContext        {            public CatalogContext(DbContextOptions&lt;CatalogContext&gt; options) : base(options)            {                }                protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)            {                base.OnConfiguring(optionsBuilder);            }                public DbSet&lt;CatalogItem&gt; CatalogItems { get; set; }        }    }  Create SeedDataProvider class in Db folderSeedDataProvider.cs    using Catalog.API.Model;        namespace Catalog.API.Db    {        public class SeedDataProvider        {            public static void Initialize(CatalogContext catalogContext)            {                if(!catalogContext.CatalogItems.Any())                {                    var catalogs = new List&lt;CatalogItem&gt;                    {                        new CatalogItem                        {                            Name = \"T-Shirt\",                            Description = \"Cats Eye T-Shirt\",                            Price = 1000,                            AvailableStock = 100,                            RestockThreshold = 10                        },                            new CatalogItem                        {                            Name = \"Samsung Mobile\",                            Description = \"Samsung A30\",                            Price = 30000,                            AvailableStock = 100,                            RestockThreshold = 5                        },                            new CatalogItem                        {                            Name = \"Meril Beauty Soap\",                            Description = \"Beauty Soap\",                            Price = 40,                            AvailableStock = 500,                            RestockThreshold = 20                        }                    };                        catalogContext.CatalogItems.AddRange(catalogs);                    catalogContext.SaveChanges();                }            }        }    }  Modify Program class as follows.Program.cs    using Catalog.API.Db;    using Microsoft.EntityFrameworkCore;        var builder = WebApplication.CreateBuilder(args);        // Add services to the container.        builder.Services.AddControllers();        builder.Services.AddDbContext&lt;CatalogContext&gt;(opt =&gt; opt.UseInMemoryDatabase(\"CatalogDB\"));        // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle    builder.Services.AddEndpointsApiExplorer();    builder.Services.AddSwaggerGen();        var app = builder.Build();        // For Seed data generation    using(var scope = app.Services.CreateScope())    {        var services = scope.ServiceProvider;        var db = services.GetRequiredService&lt;CatalogContext&gt;();        SeedDataProvider.Initialize(db);    }        // Configure the HTTP request pipeline.    if (app.Environment.IsDevelopment())    {        app.UseSwagger();        app.UseSwaggerUI();    }        app.UseHttpsRedirection();        app.UseAuthorization();        app.MapControllers();        app.Run();Here, the following line is used to configure in memory database    builder.Services.AddDbContext&lt;CatalogContext&gt;(opt =&gt; opt.UseInMemoryDatabase(\"CatalogDB\"));The following code snippet is used to initialize seed data    using(var scope = app.Services.CreateScope())    {        var services = scope.ServiceProvider;        var db = services.GetRequiredService&lt;CatalogContext&gt;();        SeedDataProvider.Initialize(db);    }  Add CatalogItemsController class in Controllers folder as follows.CatalogItemsController.cs    using Catalog.API.Db;    using Catalog.API.Model;    using Microsoft.AspNetCore.Mvc;    using Microsoft.EntityFrameworkCore;        namespace Catalog.API.Controllers    {        [Route(\"api/[controller]\")]        [ApiController]        public class CatalogItemsController : ControllerBase        {            private readonly CatalogContext _context;            private static int _count = 0;                public CatalogItemsController(CatalogContext context)            {                _context = context;            }                // GET: api/CatalogItems            [HttpGet]            public async Task&lt;ActionResult&lt;IEnumerable&lt;CatalogItem&gt;&gt;&gt; GetCatalogItems()            {                _count++;                if(_count &lt;= 3)                {                    // Sleep for 4 seconds                    Thread.Sleep(4000);                }                    if (_context.CatalogItems == null)                {                    return NotFound();                }                return await _context.CatalogItems.ToListAsync();            }                // GET: api/CatalogItems/5            [HttpGet(\"{id}\")]            public async Task&lt;ActionResult&lt;CatalogItem&gt;&gt; GetCatalogItem(int id)            {                if (_context.CatalogItems == null)                {                    return NotFound();                }                var catalogItem = await _context.CatalogItems.FindAsync(id);                    if (catalogItem == null)                {                    return NotFound();                }                    return catalogItem;            }                // PUT: api/CatalogItems/5            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPut(\"{id}\")]            public async Task&lt;IActionResult&gt; PutCatalogItem(int id, CatalogItem catalogItem)            {                if (id != catalogItem.Id)                {                    return BadRequest();                }                    _context.Entry(catalogItem).State = EntityState.Modified;                    try                {                    await _context.SaveChangesAsync();                }                catch (DbUpdateConcurrencyException)                {                    if (!CatalogItemExists(id))                    {                        return NotFound();                    }                    else                    {                        throw;                    }                }                    return NoContent();            }                // POST: api/CatalogItems            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPost]            public async Task&lt;ActionResult&lt;CatalogItem&gt;&gt; PostCatalogItem(CatalogItem catalogItem)            {                if (_context.CatalogItems == null)                {                    return Problem(\"Entity set 'CatalogContext.CatalogItems'  is null.\");                }                _context.CatalogItems.Add(catalogItem);                await _context.SaveChangesAsync();                    return CreatedAtAction(\"GetCatalogItem\", new { id = catalogItem.Id }, catalogItem);            }                // DELETE: api/CatalogItems/5            [HttpDelete(\"{id}\")]            public async Task&lt;IActionResult&gt; DeleteCatalogItem(int id)            {                if (_context.CatalogItems == null)                {                    return NotFound();                }                var catalogItem = await _context.CatalogItems.FindAsync(id);                if (catalogItem == null)                {                    return NotFound();                }                    _context.CatalogItems.Remove(catalogItem);                await _context.SaveChangesAsync();                    return NoContent();            }                private bool CatalogItemExists(int id)            {                return (_context.CatalogItems?.Any(e =&gt; e.Id == id)).GetValueOrDefault();            }        }    }Step 4: Organize BFF.WebIn this stage, we are going to configure a gateway to communicate with other services using ocelot.      Create a folder name - Routes.dev in root directory and add the following files. ocelot.catalog-api.json, ocelot.global.json, ocelot.SwaggerEndPoints.json in Routes.dev folder.        Now modify the json files as follows.  ocelot.catalog-api.json    {      \"Routes\": [        {          \"DownstreamPathTemplate\": \"/{everything}\",          \"DownstreamScheme\": \"https\",          \"SwaggerKey\": \"catalog-api\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": \"7282\"            }          ],          \"UpstreamPathTemplate\": \"/catalog/{everything}\",          \"UpstreamHttpMethod\": [            \"GET\",            \"POST\",            \"PUT\",            \"DELETE\"          ],              \"QoSOptions\": {            \"ExceptionsAllowedBeforeBreaking\": 2,            \"DurationOfBreak\": 5000,            \"TimeoutValue\": 3000          }            }      ]    }QoSOptions section of the above file basically configure QoS for Catalog service. The above configuration means that if the server does not response for 3 minutes, it will throw timeout exception. If the server throws two exceptions, it will not be accessible for five minutes.ocelot.global.json    {      \"GlobalConfiguration\": {        \"BaseUrl\": \"https://localhost:7205\"        //\"ServiceDiscoveryProvider\": {            //  \"Host\": \"localhost\",        //  \"Port\": 7205        //}      }    }ocelot.SwaggerEndPoints.json    {      \"SwaggerEndPoints\": [        {          \"Key\": \"bffweb\",          \"TransformByOcelotConfig\": false,          \"Config\": [            {              \"Name\": \"BFF.Web\",              \"Version\": \"1.0\",              \"Url\": \"https://localhost:7205/swagger/v1/swagger.json\"            }          ]        },            {          \"Key\": \"catalog-api\",          \"TransformByOcelotConfig\": true,          \"Config\": [            {              \"Name\": \"Catalog.API\",              \"Version\": \"1.0\",              \"Url\": \"https://localhost:7205/catalog/swagger/v1/swagger.json\"            }          ]        }      ]    }Note: I have added the following code block in CatalogItemController to produce timeout manually.            [HttpGet]            public async Task&lt;ActionResult&lt;IEnumerable&lt;CatalogItem&gt;&gt;&gt; GetCatalogItems()            {                _count++;                if(_count &lt;= 3)                {                    // Sleep for 4 seconds                    Thread.Sleep(4000);                }                    if (_context.CatalogItems == null)                {                    return NotFound();                }                return await _context.CatalogItems.ToListAsync();            }Step 5: Run and test the applicationNow run both web projects. In the BFF.Web, select Catalog.API-1.0 from swagger definition (“Select a definition on the top right corner”) and execute the api (CatalogItems) as follows.When we visit the first time (or quickly second time), it tells us that circuit is breaking for 5000 ms. Look at the console of BFF.Web.Then, the second time (quickly) it tells us that the circuit is open, and we cannot visit the service for 3 seconds as follows.After 3 seconds, the service is accessible. If you execute now, you will see the output like below.Source code"
  },
  
  {
    "title": "Search AD entry by ObjectSid using Novell Directory Ldap Nuget package",
    "url": "/posts/Search-AD-entry-by-ObjectSid-using-Novell-Directory-Ldap-Nuget-package/",
    "categories": "ActiveDirectory, Ldap",
    "tags": "ldap, microsoft, c#, dotnet, activedirectory",
    "date": "2023-09-25 00:00:00 +0200",
    





    
    "snippet": "SID stands for security identifier, a unique string that Windows Server automatically assigns to each computer, user and group in order to mark and clearly distinguish them.Windows SID Format :SIDs...",
    "content": "SID stands for security identifier, a unique string that Windows Server automatically assigns to each computer, user and group in order to mark and clearly distinguish them.Windows SID Format :SIDs always follow the same structure, with values separated by dashes:Novell Directory LdapNovell Directory Ldap nuget package allows you to connect to the active directory in order to perform CRUD actions on all AD objects, among other Users Groups and computers. it support both platforms windows and linux, so even if you are under kubernetes  clusters on docker containers you will be able to manage AD objects.C# code practical caseThis exemple is based on a project that was created based on .Net 6 under Visual studio 2022 and with a docker support to manage Ad Objects within a linux docker container.The nuget package version that was used are the following :&lt;PackageReference Include=\"Novell.Directory.Ldap.NETStandard\" Version=\"3.6.0\" /&gt;When we will process a search within the AD for a dedicated entry we will use a string ObjectSid instead of a bytes value. To do that we will create a helper method that will return the string value based on the input ObjectSid bytes value as bellow :1. Add Helper method to convert ObjectSID Byte value in string format public static string ConvertSidByteValueToStringValue(Byte[] sidBytes)        {            short sSubAuthorityCount = 0;            StringBuilder strSid = new StringBuilder();            strSid.Append(\"S-\");            try            {                // Add SID revision.                strSid.Append(sidBytes[0].ToString());                sSubAuthorityCount = Convert.ToInt16(sidBytes[1]);                // Next six bytes are SID authority value.                if (sidBytes[2] != 0 || sidBytes[3] != 0)                {                    string strAuth = String.Format(\"0x{0:2x}{1:2x}{2:2x}{3:2x}{4:2x}{5:2x}\",                                   (Int16)sidBytes[2],                                   (Int16)sidBytes[3],                                   (Int16)sidBytes[4],                                   (Int16)sidBytes[5],                                   (Int16)sidBytes[6],                                   (Int16)sidBytes[7]);                    strSid.Append(\"-\");                    strSid.Append(strAuth);                }                else                {                    Int64 iVal = sidBytes[7] +                         (sidBytes[6] &lt;&lt; 8) +                         (sidBytes[5] &lt;&lt; 16) +                         (sidBytes[4] &lt;&lt; 24);                    strSid.Append(\"-\");                    strSid.Append(iVal.ToString());                }                // Get sub authority count...                int idxAuth = 0;                for (int i = 0; i &lt; sSubAuthorityCount; i++)                {                    idxAuth = 8 + i * 4;                    UInt32 iSubAuth = BitConverter.ToUInt32(sidBytes, idxAuth);                    strSid.Append(\"-\");                    strSid.Append(iSubAuth.ToString());                }            }            catch (Exception ex)            {                Trace.TraceWarning(ex.Message);                throw;            }            return strSid.ToString();        }This method will get ObjectSid information parts from the array of Bytes input value as bellow :byte[0]      - Revision Levelbyte[1]      - count of Sub-Authoritiesbyte[2 - 7]  - 48 bit Authority(big-endian)byte[8 +]    - n Sub-Authorities, 32 bits And after that we return a String ObjectSID on the format bellow :S-{Revision}-{Authority}-{ SubAuthority1}-{ SubAuthority2}...-{ SubAuthorityN}2. Call Active Directory to retrieve User informations based on objectSid string valueAdding Novell directiveusing Novell.Directory.Ldap;.....Adding the search method to get the User entry object/// Exemple of Dn Value  : OU=User,OU=Accounts,DC=USA,DC=NY        /// Exemple of objectSidStringValue Value  : S-1-5-15-420314761-778715008-4547327-1845947        /// Exemple of objectCategory Value  : User or Group or Computer        /// Exemple of OutputProps Values : \"description\",\"lastLogon\",\"email\",\"name\", \"login\"        public List&lt;Attributes&lt;string, string&gt;&gt;? GetLdapEntryByObjectSid(string Dn, string objectSidStringValue, string objectCategory, string[] OutputProps)        {            var ldapConnectionOptions = new LdapConnectionOptions();            ldapConnectionOptions.UseSsl();            var ldapConx = new LdapConnection(ldapConnectionOptions);            List&lt;Attributes&lt;string, string&gt;&gt; listAttributes = new List&lt;Attributes&lt;string, string&gt;&gt;();            string Filter = $\"(&amp;(objectSid={objectSidStringValue})(objectCategory={objectCategory}))\";                        if (!string.IsNullOrEmpty(Filter))            {                var searchQuery = ldapConx.Search(Dn, Novell.Directory.Ldap.LdapConnection.ScopeSub, Filter, OutputProps, false);                if (searchQuery != null)                {                    while (searchQuery.HasMore())                    {                        LdapEntry nextEntry = null;                            nextEntry = searchQuery.Next();                            //SID Case                             if (OutputProps.Contains(\"objectSid\"))                            {                                //Get Sid Property Bytes value to be converted into string clear value                                var objectSid = nextEntry.GetAttributeSet().FirstOrDefault(e =&gt; e.Key.Equals(\"objectSid\"));                                if (objectSid.Value != null)                                {                                    var sidStringFormat = ConvertSidByteValueToStringValue(objectSid.Value.ByteValue);                                    listAttributes.Add(new Attributes&lt;string, string&gt;(objectSid.Key, sidStringFormat));                                }                            }                            listAttributes.AddRange(nextEntry.GetAttributeSet()                                .Where(e =&gt; !e.Key.Equals(\"objectSid\"))                                .Select(e =&gt; new Attributes&lt;string, string&gt;(e.Key, e.Value.StringValue))                                .ToList());                                           }                }            }            return listAttributes;        }The GetLdapEntryByObjectSid method will process a searchQuery within ldap based on the objectSid filter and also the objectCategory in this example User filter. As mentioned the objectSid within Active directory are persisted as a byte so we will call our Helper method to convert it into a string value: var sidStringFormat = ConvertSidByteValueToStringValue(objectSid.Value.ByteValue);The returned list of properties will contains all properties as string readable values, so we can use them also to process a new search based on other property.Links : Novell Directory - GitHub repositoryNovell Directory - Nuget package"
  },
  
  {
    "title": "AZ-400 Certification Path",
    "url": "/posts/AZ-400-Certification-Path/",
    "categories": "Microsoft, Certification",
    "tags": "certification, microsoft, azuredevops, dotnet",
    "date": "2023-09-25 00:00:00 +0200",
    





    
    "snippet": "Microsoft certification paths changesBoth the MCSD and MCT certifications were discontinued by Microsoft in 2017. They were replaced by newer certification programs that reflect the changing demand...",
    "content": "Microsoft certification paths changesBoth the MCSD and MCT certifications were discontinued by Microsoft in 2017. They were replaced by newer certification programs that reflect the changing demands of the tech industry and the evolving needs of professionals.The MCSD certification was replaced by the Azure Developer Associate certification, which is a newer certification program that is designed for developers who want to demonstrate their expertise in buildingand deploying cloud-based solutions using Microsoft Azure. The MCT certification was replaced by the Microsoft Certified: Learning Consultant certification, which is a program that recognizes individuals who have demonstrated expertise in designing and delivering training programs on Microsoft technologies.Microsoft offers a wide range of certification programs that are designed to validate the skills of professionals in a variety of different roles. Some of the most popular certification programs offered by Microsoft by role include:      Developers: Microsoft offers several certification programs that are designed for developers, including the Azure Developer Associate certification, the Microsoft Certified: Power Platform Developer Associate certification, and noth the Microsoft Certified: Azure Solutions Architect Expert certification and DevOps Engineer Expert.        IT Administrators: Microsoft offers several certification programs that are designed for IT administrators, including the Microsoft Certified: Azure Administrator Associate certification, the Microsoft Certified: Azure Security Engineer Associate certification, and the Microsoft Certified: Windows Server 2016 certification.        Data Professionals: Microsoft offers several certification programs that are designed for data professionals, including the Microsoft Certified: Data Analyst Associate certification, the Microsoft Certified: Data Scientist Associate certification, and the Microsoft Certified: Azure Data Engineer Associate certification.        Business Professionals: Microsoft offers several certification programs that are designed for business professionals, including the Microsoft Certified: Power Platform Fundamentals certification, the Microsoft Certified: Dynamics 365 Fundamentals certification, and the Microsoft Certified: Dynamics 365 Marketing certification.        Educators: Microsoft offers several certification programs that are designed for educators, including the Microsoft Certified: Educator certification, the Microsoft Certified: Trainer certification, and the Microsoft Certified: Learning Consultant certification.  We will focus in this post on Developers role. So, actually for a dotnet developer the best Microsoft certification to achieve is by following the DevOps Engineer Expert Certification path. Currently the different missions of a dotnet developer require some experience on the devops side for the build and release parts and as well as on the Microsoft Azure part too.Describe certificate pathAccording to The 2021 Pearson VUE Value of IT Certification survey 91% of certified IT professional get more professional credibility, 76% are more valuable to their employers, and 28% of the surveyed candidates reported a salary increase as a benefit of getting certified.Azure DevOps Expert Certification is a three-stars certification that falls under the Microsoft expert-level certifications.AZ-400 Exam PrerequisiteA candidate for this exam must have written either or both of the assoiate Microsoft certification in the schema bellow. Note that the Exam AZ-900: Microsoft Azure Fundamentals are optional and it open to you to pass it. From my part i choose to write the Azure Developer Associate because of my experience as a software developer. For Devops engineer it more recommended to pass the Administrator Associate certification in order to achieve the DevOps Engineer Expert one.Study for your examThe AZ-400 Exam contains about 40-60 questions; however, the number can vary depending on the exam. with a duration of about 180 minutes. Candidates are required to have a passing score of 700/1000 to earn the certification.Structure of the exam      Single-choice questions(with YES/NO options) Cannot be reviewed, skipped, or returned to later.        Single-choice questions.        Multiple-choice questions.        Arrange in the right sequence questions.        Case-study with multiple questions.  Study planA typical study plan may last for a month at about 5 hours of daily study. The study plan depends on the level of experience candidates have on the various topics measured in the exam. Experienced DevOps professionals may spend less time compared to the beginner fellows.Study materialsThis exam measures your ability to accomplish the following technical tasks: develop an instrumentation strategy; develop a Site Reliability Engineering (SRE) strategy; develop a security and compliance plan; manage source control; facilitate communication and collaboration; define and implement continuous integration; and define and implement continuous delivery and release management strategy. The following materials should be helpful.Microsoft learn: Azure DevOps Learning Path      Azure Devops Labs: get hands-on experience using various Azure DevOps services to solve real-life scenario business problems.        Azure DevOps documentation        Azure documentation        Practice question materialsThe listed links below are very helpful and may tell you what the questions may look like. All the objectives of this exam are covered so you’ll be ready for any question on the exam.  AZ-400: Designing and Implementing Microsoft DevOps Solutions Microsoft Official Practice TestWhizlabs-AZ-400 Practice testExamTopics-AZ-400 Practice testScheduling and Taking your examIt is important you arrive at your test center 15-30 minutes before your scheduled appointment time. This will give you adequate time to complete the necessary sign-in procedures. If you arrive more than 15 minutes late for an exam and are refused admission, payments are due for the exam and delivery fees.Be prepared to show two (2) valid forms of personal identification, a National Identity card, Drivers license, or an International Passport.TipsMark questions whose answers you are not sure about for review, and revisit them when done with the others.Don’t leave any questions unanswered and make sure to submit before proceeding to the next section.Case-study questions come after the first section.Make sure you keep to time.You will receive your transcript upon submission in less than an hour, and an acclaim badge upon passing the exam in your mailbox. Share your badge on social networks like LinkedIn, Twitter, or Facebook.Voila, congratulations, you are now a Microsoft Certified: Azure DevOps Expert, you deserve it. Keep your skills sharp and transfer your knowledge to real work situations.Thank you for reading, I hope this helps you prepare and pass the AZ-400 examination.You can view my Azure DevOps badges here 😊Microsoft Certified: Azure Developer AssociateMicrosoft Certified: DevOps Engineer ExpertReferenceMicrosoft Certified: DevOps Engineer ExpertAzure DevOps Labs2021 Pearson VUE Value of IT CertificationIntroduction to the AZ-400: Designing and Implementing Microsoft DevOps Solutions Exam"
  },
  
  {
    "title": "Implementing API gateway using ocelot in asp.net core application",
    "url": "/posts/Implementing-Ocelot-Gateway/",
    "categories": "Microservices, Ocelot",
    "tags": "microsoft, aspnetcore, csharp, microservices, ocelot, webapi, c#, gateway",
    "date": "2023-09-24 00:00:00 +0200",
    





    
    "snippet": "API Gateway is an API management tools that sits between a client application and backend application. It agregates different services, maintain load balancing and work as reverse proxy. Ocelot is ...",
    "content": "API Gateway is an API management tools that sits between a client application and backend application. It agregates different services, maintain load balancing and work as reverse proxy. Ocelot is an api managment tool which is very powerful and best fit for .net application.Tools and technologies used  Visual Studio 2022  .NET 6.0  In Memory Database  Entity Framework  ASP.NET Core Web API  C#  OcelotImplementationStep 1: Create solution and projects.  Create a solution name APIGateway  Add 4 new web api project, name - Catalog.API, Location.API, Ordering.API and BFF.Web in the solution.Here, BFF.Web project will act as API Gateway.Step 2: Install nuget packages.  Install following nuget package in Catalog.API Project    PM&gt; Install-Package Microsoft.EntityFrameworkCore.InMemoryPM&gt; Install-Package Microsoft.EntityFrameworkCore.SqlServerPM&gt; Install-Package Microsoft.EntityFrameworkCore.Tools        Install following nuget package in Ordering.API Project    PM&gt; Install-Package Microsoft.EntityFrameworkCorePM&gt; Install-Package Microsoft.EntityFrameworkCore.InMemoryPM&gt; Install-Package Microsoft.EntityFrameworkCore.SqlServerPM&gt; Install-Package Microsoft.EntityFrameworkCore.Tools        Install following nuget packages in BFF.Web Project    PM&gt; Install-Package OcelotPM&gt; Install-Package Ocelot.Cache.CacheManager      Step 3: Organize Catalog.API Project  Create a Product model class in Catalog.API/Model folderProduct.cs    using System.ComponentModel.DataAnnotations;    using System.ComponentModel.DataAnnotations.Schema;        namespace Catalog.API.Model    {        public class Product        {            [Key]            [DatabaseGenerated(DatabaseGeneratedOption.Identity)]            public int Id { get; set; }            public string Name { get; set; }                public string Description { get; set; }                public decimal Price { get; set; }                public int AvailableStock { get; set; }                public int RestockThreshold { get; set; }        }    }  Create a CatalogContext class in Catalog.API/Db folderCatalogContext.cs    using Catalog.API.Model;    using Microsoft.EntityFrameworkCore;        namespace Catalog.API.Db    {        public class CatalogContext : DbContext        {            public CatalogContext(DbContextOptions&lt;CatalogContext&gt; options) : base(options)            {                }                protected override void OnModelCreating(ModelBuilder modelBuilder)            {                }                protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)            {                base.OnConfiguring(optionsBuilder);            }                public DbSet&lt;Product&gt; Products { get; set; }        }    }  Modify Program.cs file as follows    using Catalog.API.Db;    using Microsoft.EntityFrameworkCore;        var builder = WebApplication.CreateBuilder(args);        // Add services to the container.        builder.Services.AddControllers();        builder.Services.AddDbContext&lt;CatalogContext&gt;(opt =&gt; opt.UseInMemoryDatabase(\"CatalogDB\"));        // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle    builder.Services.AddEndpointsApiExplorer();    builder.Services.AddSwaggerGen();        var app = builder.Build();        // Configure the HTTP request pipeline.    if (app.Environment.IsDevelopment())    {        app.UseSwagger();        app.UseSwaggerUI();    }        app.UseHttpsRedirection();        app.UseAuthorization();        app.MapControllers();        app.Run();  Create a conroller class name ProductsController in Catalog.API/Controllers folderCatalogContoller.cs    using System;    using System.Collections.Generic;    using System.Linq;    using System.Threading.Tasks;    using Microsoft.AspNetCore.Http;    using Microsoft.AspNetCore.Mvc;    using Microsoft.EntityFrameworkCore;    using Catalog.API.Db;    using Catalog.API.Model;        namespace Catalog.API.Controllers    {        [Route(\"api/[controller]\")]        [ApiController]        public class ProductsController : ControllerBase        {            private readonly CatalogContext _context;                public ProductsController(CatalogContext context)            {                _context = context;            }                // GET: api/Products            [HttpGet(\"GetAll\")]            public async Task&lt;ActionResult&lt;IEnumerable&lt;Product&gt;&gt;&gt; GetProducts()            {                return await _context.Products.ToListAsync();            }                // GET: api/Products/5            [HttpGet(\"{id}\")]            public async Task&lt;ActionResult&lt;Product&gt;&gt; GetProduct(int id)            {                var product = await _context.Products.FindAsync(id);                    if (product == null)                {                    return NotFound();                }                    return product;            }                // PUT: api/Products/5            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPut(\"Edit/{id}\")]            public async Task&lt;IActionResult&gt; PutProduct(int id, Product product)            {                if (id != product.Id)                {                    return BadRequest();                }                    _context.Entry(product).State = EntityState.Modified;                    try                {                    await _context.SaveChangesAsync();                }                catch (DbUpdateConcurrencyException)                {                    if (!ProductExists(id))                    {                        return NotFound();                    }                    else                    {                        throw;                    }                }                    return NoContent();            }                // POST: api/Products            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPost(\"Add\")]            public async Task&lt;ActionResult&lt;Product&gt;&gt; PostProduct(Product product)            {                _context.Products.Add(product);                await _context.SaveChangesAsync();                    return CreatedAtAction(\"GetProduct\", new { id = product.Id }, product);            }                // DELETE: api/Products/5            [HttpDelete(\"Delete/{id}\")]            public async Task&lt;IActionResult&gt; DeleteProduct(int id)            {                var product = await _context.Products.FindAsync(id);                if (product == null)                {                    return NotFound();                }                    _context.Products.Remove(product);                await _context.SaveChangesAsync();                    return NoContent();            }                private bool ProductExists(int id)            {                return _context.Products.Any(e =&gt; e.Id == id);            }        }    }Step 4: Organize Ordering.API Project  Create a Order model class in Ordering.API/Model folderOrder.cs    namespace Ordering.API.Models    {        public class Order        {            public int Id { get; set; }            public string Address { get; set; }                public DateTime OrderDate { get; set; }                public string Comments { get; set; }        }    }  Create a OrderingContext class in Ordering.API/Db folderOrderingContext.cs    using Microsoft.EntityFrameworkCore;    using Ordering.API.Models;        namespace Ordering.API.Db    {        public class OrderingContext : DbContext        {            public OrderingContext(DbContextOptions&lt;OrderingContext&gt; options) : base(options)            {                }            public DbSet&lt;Ordering.API.Models.Order&gt; Order { get; set; }        }    }  Modify Program.cs file as follows    using Microsoft.EntityFrameworkCore;    using Ordering.API.Db;        var builder = WebApplication.CreateBuilder(args);        // Add services to the container.        builder.Services.AddControllers();        builder.Services.AddDbContext&lt;OrderingContext&gt;(opt =&gt; opt.UseInMemoryDatabase(\"CatalogDB\"));        // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle    builder.Services.AddEndpointsApiExplorer();    builder.Services.AddSwaggerGen();        var app = builder.Build();        // Configure the HTTP request pipeline.    if (app.Environment.IsDevelopment())    {        app.UseSwagger();        app.UseSwaggerUI();    }        app.UseHttpsRedirection();        app.UseAuthorization();        app.MapControllers();        app.Run();  Create a conroller class name OrdersController in Ordering.API/Controllers folderOrdersController.cs    using System;    using System.Collections.Generic;    using System.Linq;    using System.Threading.Tasks;    using Microsoft.AspNetCore.Http;    using Microsoft.AspNetCore.Mvc;    using Microsoft.EntityFrameworkCore;    using Ordering.API.Db;    using Ordering.API.Models;        namespace Ordering.API.Controllers    {        [Route(\"api/[controller]\")]        [ApiController]        public class OrdersController : ControllerBase        {            private readonly OrderingContext _context;                public OrdersController(OrderingContext context)            {                _context = context;            }                // GET: api/Orders            [HttpGet(\"GetAll\")]            public async Task&lt;ActionResult&lt;IEnumerable&lt;Order&gt;&gt;&gt; GetOrder()            {                return await _context.Order.ToListAsync();            }                // GET: api/Orders/5            [HttpGet(\"{id}\")]            public async Task&lt;ActionResult&lt;Order&gt;&gt; GetOrder(int id)            {                var order = await _context.Order.FindAsync(id);                    if (order == null)                {                    return NotFound();                }                    return order;            }                // PUT: api/Orders/5            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPut(\"Edit/{id}\")]            public async Task&lt;IActionResult&gt; PutOrder(int id, Order order)            {                if (id != order.Id)                {                    return BadRequest();                }                    _context.Entry(order).State = EntityState.Modified;                    try                {                    await _context.SaveChangesAsync();                }                catch (DbUpdateConcurrencyException)                {                    if (!OrderExists(id))                    {                        return NotFound();                    }                    else                    {                        throw;                    }                }                    return NoContent();            }                // POST: api/Orders            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPost(\"Add\")]            public async Task&lt;ActionResult&lt;Order&gt;&gt; PostOrder(Order order)            {                _context.Order.Add(order);                await _context.SaveChangesAsync();                    return CreatedAtAction(\"GetOrder\", new { id = order.Id }, order);            }                // DELETE: api/Orders/5            [HttpDelete(\"Delete/{id}\")]            public async Task&lt;IActionResult&gt; DeleteOrder(int id)            {                var order = await _context.Order.FindAsync(id);                if (order == null)                {                    return NotFound();                }                    _context.Order.Remove(order);                await _context.SaveChangesAsync();                    return NoContent();            }                private bool OrderExists(int id)            {                return _context.Order.Any(e =&gt; e.Id == id);            }        }    }Step 5: Organize Location.API Project  Create CountriesController in Location.API/Controllers folder    using Microsoft.AspNetCore.Mvc;        namespace Location.API.Controllers    {        [ApiController]        [Route(\"api/[controller]\")]        public class CountriesController : ControllerBase        {          [HttpGet(\"GetAll\")]          public IEnumerable&lt;string&gt; Get()            {                return new string[] {\"Morrocco\",\"Spain\", \"Portugal\" };            }        }    }Step 6: Organize BFF.Web (API Gateway) Project  Add a configuraton file for api gateway. I keep this file name - ocelot.json. Add this file in the root directory.ocelot.json    {      //---Location Service: Start ----------//      \"Routes\": [        {          \"DownstreamPathTemplate\": \"/api/Countries/GetAll\",          \"DownstreamScheme\": \"https\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": 7003            }          ],              // Configure caching          // the cache will expire after 30 seconds.          \"FileCacheOptions\": {            \"TtlSeconds\": 30,            \"Region\": \"countriescaching\"          },              \"UpstreamPathTemplate\": \"/Countries/GetAll\",          \"UpstreamHttpMethod\": [ \"Get\" ],              // Enable case sensative Routing/URL          \"RouteIsCaseSensitive\": true        },            //---Location Service: End ----------//            // Catalog Services        //------------------//        {          \"DownstreamPathTemplate\": \"/api/Products/GetAll\",          \"DownstreamScheme\": \"https\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": 7282            }          ],              // Implement rate limiting          // maximum admitted 1 per 5s.          \"RateLimitOptions\": {            \"ClientWhitelist\": [              // This is an array used to specify the clients that should not be affected by the rate-limiting            ],            \"EnableRateLimiting\": true,            \"Period\": \"5s\",            \"PeriodTimespan\": 1,            \"Limit\": 1          },              \"UpstreamPathTemplate\": \"/Products/GetAll\",          \"UpstreamHttpMethod\": [ \"Get\" ]        },        {          \"DownstreamPathTemplate\": \"/api/Products/Add\",          \"DownstreamScheme\": \"https\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": 7282            }          ],              \"UpstreamPathTemplate\": \"/Products/Add\",          \"UpstreamHttpMethod\": [ \"Post\" ]        },            {          \"DownstreamPathTemplate\": \"/api/Products/{id}\",          \"DownstreamScheme\": \"https\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": 7282            }          ],              \"UpstreamPathTemplate\": \"/Products/{id}\",          \"UpstreamHttpMethod\": [ \"Get\" ]        },            {          \"DownstreamPathTemplate\": \"/api/Products/Edit/{id}\",          \"DownstreamScheme\": \"https\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": 7282            }          ],              \"UpstreamPathTemplate\": \"/Products/Edit/{id}\",          \"UpstreamHttpMethod\": [ \"Put\" ]        },            {          \"DownstreamPathTemplate\": \"/api/Products/Delete/{id}\",          \"DownstreamScheme\": \"https\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": 7282            }          ],              \"UpstreamPathTemplate\": \"/Products/Delete/{id}\",          \"UpstreamHttpMethod\": [ \"Delete\" ]        },            //---Catalog service : End ------------//            //---Ordering Service: Start ----------//        // Catch All Routing        {          \"DownstreamPathTemplate\": \"/{url}\",          \"DownstreamScheme\": \"https\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": 7126            }          ],              \"UpstreamPathTemplate\": \"/{url}\",          \"UpstreamHttpMethod\": [ \"Get\", \"Post\", \"Put\", \"Delete\" ]        }          ],          //---Ordering Service: End ----------//          //https://localhost:7282/api/Products/GetAll          \"GlobalConfiguration\": {        // enable request correleation id to capture request information        \"RequestIdKey\": \"X-Correlation-Id\",        \"BaseUrl\": \"https://localhost:7205/\"      }    }  Modify Program.cs file as followsProgram.cs    using Ocelot.DependencyInjection;    using Ocelot.Middleware;    using Ocelot.Cache.CacheManager;            var builder = WebApplication.CreateBuilder(args);            var environment = Environment.GetEnvironmentVariable(\"ASPNETCORE_ENVIRONMENT\");    builder.Configuration.SetBasePath(Directory.GetCurrentDirectory())        .AddJsonFile(\"ocelot.json\", optional: false, reloadOnChange: true)        .AddEnvironmentVariables();            // Add services to the container.        builder.Services.AddControllers();    // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle    builder.Services.AddEndpointsApiExplorer();        // Swagger for ocelot    //builder.Services.AddSwaggerForOcelot(builder.Configuration);    //builder.Services.AddSwaggerForOcelot();    builder.Services.AddSwaggerGen();        //For ocelot    builder.Services.AddOcelot()                // Added for caching        .AddCacheManager(x =&gt; {            x.WithDictionaryHandle();        });        var app = builder.Build();        // Configure the HTTP request pipeline.    if (app.Environment.IsDevelopment())    {        app.UseSwagger();        app.UseSwaggerUI();        //app.UseSwaggerForOcelotUI();    }        app.UseOcelot();        app.UseHttpsRedirection();        app.UseAuthorization();        app.MapControllers();        app.Run();Step 7: Run and Test application  Now run multiple (all) projects and test application using postman.  You have to check application using api gateway.  For Location service, test using https://localhost:7205/Countries/GetAll  For Catalog service, test using https://localhost:7205/Products/{endpoints}  For Ordering service, test using https://localhost:7205/api/Orders/{endpoints}Note:Configure caching in api gateway  Added the following section in ocelot.json file.    \"FileCacheOptions\": {    \"TtlSeconds\": 30,    \"Region\": \"countriescaching\"    }  Added the following code block in the the Program.cs file as follows    //For ocelotbuilder.Services.AddOcelot()            // Added for caching    .AddCacheManager(x =&gt; {        x.WithDictionaryHandle();    });      Enable case sensative URL  Add following blocks in ocelot.json for case sensative URL          // Enable case sensative Routing/URL      \"RouteIsCaseSensitive\": true      Implement rate limiting  Add following blocks in ocelot.json for rate limiting    // Implement rate limiting    // maximum admitted 1 per 5s.    \"RateLimitOptions\": {    \"ClientWhitelist\": [        // This is an array used to specify the clients that should not be affected by the rate-limiting    ],    \"EnableRateLimiting\": true,    \"Period\": \"5s\",    \"PeriodTimespan\": 1,    \"Limit\": 1    }Catch all routing  Add following blocks in ocelot.json for catch all routing    {        \"DownstreamPathTemplate\": \"/{url}\",        \"DownstreamScheme\": \"https\",        \"DownstreamHostAndPorts\": [        {            \"Host\": \"localhost\",            \"Port\": 7126        }        ],            \"UpstreamPathTemplate\": \"/{url}\",        \"UpstreamHttpMethod\": [ \"Get\", \"Post\", \"Put\", \"Delete\" ]    }Source code"
  },
  
  {
    "title": "Configure Swagger on api gateway using ocelot in asp.net core application",
    "url": "/posts/Configure-Swagger-For-Ocelot-Gateway/",
    "categories": "Microservices, Ocelot",
    "tags": "microsoft, aspnetcore, csharp, microservices, ocelot, webapi, c#, gateway, swagger",
    "date": "2023-09-24 00:00:00 +0200",
    





    
    "snippet": "IntroductionSwagger configuration on API gateway is not as simple as you are configure normal application. You have to configure it in different way. In this article I will create an API gateway us...",
    "content": "IntroductionSwagger configuration on API gateway is not as simple as you are configure normal application. You have to configure it in different way. In this article I will create an API gateway using ocelot and asp.net core application and show you how to configure swagger on API gateway.Tools and technologies used  Visual Studio 2022  .NET 6.0  In Memory Database  Entity Framework  ASP.NET Core Web API  C#  Ocelot and  MMLib.SwaggerForOcelotImplementationStep 1: Create solution and projects.  Create a solution name APIGateway  Add 4 new web api project, name - Catalog.API, Location.API, Ordering.API and BFF.Web in the solution.Here, BFF.Web project will act as API Gateway.Step 2: Install nuget packages.  Install following nuget package in Catalog.API Project    PM&gt; Install-Package Microsoft.EntityFrameworkCore.InMemoryPM&gt; Install-Package Microsoft.EntityFrameworkCore.SqlServerPM&gt; Install-Package Microsoft.EntityFrameworkCore.Tools        Install following nuget package in Ordering.API Project    PM&gt; Install-Package Microsoft.EntityFrameworkCorePM&gt; Install-Package Microsoft.EntityFrameworkCore.InMemoryPM&gt; Install-Package Microsoft.EntityFrameworkCore.SqlServerPM&gt; Install-Package Microsoft.EntityFrameworkCore.Tools        Install following nuget packages in BFF.Web Project    PM&gt; Install-Package OcelotPM&gt; Install-Package Ocelot.Provider.PollyPM&gt; Install-Package Ocelot.Cache.CacheManagerPM&gt; Install-Package MMLib.SwaggerForOcelot      Step 3: Organize Catalog.API Project  Create a Product model class in Catalog.API/Model folderProduct.cs    using System.ComponentModel.DataAnnotations;    using System.ComponentModel.DataAnnotations.Schema;        namespace Catalog.API.Model    {        public class Product        {            [Key]            [DatabaseGenerated(DatabaseGeneratedOption.Identity)]            public int Id { get; set; }            public string Name { get; set; }                public string Description { get; set; }                public decimal Price { get; set; }                public int AvailableStock { get; set; }                public int RestockThreshold { get; set; }        }    }  Create a CatalogContext class in Catalog.API/Db folderCatalogContext.cs    using Catalog.API.Model;    using Microsoft.EntityFrameworkCore;        namespace Catalog.API.Db    {        public class CatalogContext : DbContext        {            public CatalogContext(DbContextOptions&lt;CatalogContext&gt; options) : base(options)            {                }                protected override void OnModelCreating(ModelBuilder modelBuilder)            {                }                protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)            {                base.OnConfiguring(optionsBuilder);            }                public DbSet&lt;Product&gt; Products { get; set; }        }    }  Modify Program.cs file as follows    using Catalog.API.Db;    using Microsoft.EntityFrameworkCore;        var builder = WebApplication.CreateBuilder(args);        // Add services to the container.        builder.Services.AddControllers();        builder.Services.AddDbContext&lt;CatalogContext&gt;(opt =&gt; opt.UseInMemoryDatabase(\"CatalogDB\"));        // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle    builder.Services.AddEndpointsApiExplorer();    builder.Services.AddSwaggerGen();        var app = builder.Build();        // Configure the HTTP request pipeline.    if (app.Environment.IsDevelopment())    {        app.UseSwagger();        app.UseSwaggerUI();    }        app.UseHttpsRedirection();        app.UseAuthorization();        app.MapControllers();        app.Run();  Create a conroller class name ProductsController in Catalog.API/Controllers folderCatalogController.cs    using System;    using System.Collections.Generic;    using System.Linq;    using System.Threading.Tasks;    using Microsoft.AspNetCore.Http;    using Microsoft.AspNetCore.Mvc;    using Microsoft.EntityFrameworkCore;    using Catalog.API.Db;    using Catalog.API.Model;        namespace Catalog.API.Controllers    {        [Route(\"api/[controller]\")]        [ApiController]        public class ProductsController : ControllerBase        {            private readonly CatalogContext _context;                public ProductsController(CatalogContext context)            {                _context = context;            }                // GET: api/Products            [HttpGet(\"GetAll\")]            public async Task&lt;ActionResult&lt;IEnumerable&lt;Product&gt;&gt;&gt; GetProducts()            {                return await _context.Products.ToListAsync();            }                // GET: api/Products/5            [HttpGet(\"{id}\")]            public async Task&lt;ActionResult&lt;Product&gt;&gt; GetProduct(int id)            {                var product = await _context.Products.FindAsync(id);                    if (product == null)                {                    return NotFound();                }                    return product;            }                // PUT: api/Products/5            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPut(\"Edit/{id}\")]            public async Task&lt;IActionResult&gt; PutProduct(int id, Product product)            {                if (id != product.Id)                {                    return BadRequest();                }                    _context.Entry(product).State = EntityState.Modified;                    try                {                    await _context.SaveChangesAsync();                }                catch (DbUpdateConcurrencyException)                {                    if (!ProductExists(id))                    {                        return NotFound();                    }                    else                    {                        throw;                    }                }                    return NoContent();            }                // POST: api/Products            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPost(\"Add\")]            public async Task&lt;ActionResult&lt;Product&gt;&gt; PostProduct(Product product)            {                _context.Products.Add(product);                await _context.SaveChangesAsync();                    return CreatedAtAction(\"GetProduct\", new { id = product.Id }, product);            }                // DELETE: api/Products/5            [HttpDelete(\"Delete/{id}\")]            public async Task&lt;IActionResult&gt; DeleteProduct(int id)            {                var product = await _context.Products.FindAsync(id);                if (product == null)                {                    return NotFound();                }                    _context.Products.Remove(product);                await _context.SaveChangesAsync();                    return NoContent();            }                private bool ProductExists(int id)            {                return _context.Products.Any(e =&gt; e.Id == id);            }        }    }Step 4: Organize Ordering.API Project  Create a Order model class in Ordering.API/Model folderOrder.cs    namespace Ordering.API.Models    {        public class Order        {            public int Id { get; set; }            public string Address { get; set; }                public DateTime OrderDate { get; set; }                public string Comments { get; set; }        }    }  Create a OrderingContext class in Ordering.API/Db folderOrderingContext.cs    using Microsoft.EntityFrameworkCore;    using Ordering.API.Models;        namespace Ordering.API.Db    {        public class OrderingContext : DbContext        {            public OrderingContext(DbContextOptions&lt;OrderingContext&gt; options) : base(options)            {                }            public DbSet&lt;Ordering.API.Models.Order&gt; Order { get; set; }        }    }  Modify Program.cs file as follows    using Microsoft.EntityFrameworkCore;    using Ordering.API.Db;        var builder = WebApplication.CreateBuilder(args);        // Add services to the container.        builder.Services.AddControllers();        builder.Services.AddDbContext&lt;OrderingContext&gt;(opt =&gt; opt.UseInMemoryDatabase(\"CatalogDB\"));        // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle    builder.Services.AddEndpointsApiExplorer();    builder.Services.AddSwaggerGen();        var app = builder.Build();        // Configure the HTTP request pipeline.    if (app.Environment.IsDevelopment())    {        app.UseSwagger();        app.UseSwaggerUI();    }        app.UseHttpsRedirection();        app.UseAuthorization();        app.MapControllers();        app.Run();      Create a conroller class name OrdersController in Ordering.API/Controllers folderOrdersController.cs    using System;    using System.Collections.Generic;    using System.Linq;    using System.Threading.Tasks;    using Microsoft.AspNetCore.Http;    using Microsoft.AspNetCore.Mvc;    using Microsoft.EntityFrameworkCore;    using Ordering.API.Db;    using Ordering.API.Models;        namespace Ordering.API.Controllers    {        [Route(\"api/[controller]\")]        [ApiController]        public class OrdersController : ControllerBase        {            private readonly OrderingContext _context;                public OrdersController(OrderingContext context)            {                _context = context;            }                // GET: api/Orders            [HttpGet(\"GetAll\")]            public async Task&lt;ActionResult&lt;IEnumerable&lt;Order&gt;&gt;&gt; GetOrder()            {                return await _context.Order.ToListAsync();            }                // GET: api/Orders/5            [HttpGet(\"{id}\")]            public async Task&lt;ActionResult&lt;Order&gt;&gt; GetOrder(int id)            {                var order = await _context.Order.FindAsync(id);                    if (order == null)                {                    return NotFound();                }                    return order;            }                // PUT: api/Orders/5            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPut(\"Edit/{id}\")]            public async Task&lt;IActionResult&gt; PutOrder(int id, Order order)            {                if (id != order.Id)                {                    return BadRequest();                }                    _context.Entry(order).State = EntityState.Modified;                    try                {                    await _context.SaveChangesAsync();                }                catch (DbUpdateConcurrencyException)                {                    if (!OrderExists(id))                    {                        return NotFound();                    }                    else                    {                        throw;                    }                }                    return NoContent();            }                // POST: api/Orders            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPost(\"Add\")]            public async Task&lt;ActionResult&lt;Order&gt;&gt; PostOrder(Order order)            {                _context.Order.Add(order);                await _context.SaveChangesAsync();                    return CreatedAtAction(\"GetOrder\", new { id = order.Id }, order);            }                // DELETE: api/Orders/5            [HttpDelete(\"Delete/{id}\")]            public async Task&lt;IActionResult&gt; DeleteOrder(int id)            {                var order = await _context.Order.FindAsync(id);                if (order == null)                {                    return NotFound();                }                    _context.Order.Remove(order);                await _context.SaveChangesAsync();                    return NoContent();            }                private bool OrderExists(int id)            {                return _context.Order.Any(e =&gt; e.Id == id);            }        }    }Step 5: Organize Location.API Project  Create CountriesController in Location.API/Controllers folder    using Microsoft.AspNetCore.Mvc;        namespace Location.API.Controllers    {        [ApiController]        [Route(\"api/[controller]\")]        public class CountriesController : ControllerBase        {          [HttpGet(\"GetAll\")]          public IEnumerable&lt;string&gt; Get()            {                return new string[] {\"America\",\"Bangladesh\", \"Canada\" };            }        }    }Step 6: Organize BFF.Web (API Gateway) Project  Create a folder name Routes and add the following files in that folderocelot.catalog.api.json    {      \"Routes\": [        {          \"DownstreamPathTemplate\": \"/{everything}\",          \"DownstreamScheme\": \"https\",          \"SwaggerKey\": \"catalog\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": \"7282\"            }          ],          \"UpstreamPathTemplate\": \"/catalog/{everything}\",          \"UpstreamHttpMethod\": [            \"GET\",            \"POST\",            \"PUT\",            \"DELETE\"          ]        }      ]    }ocelot.location.api.json    {      \"Routes\": [        {          \"DownstreamPathTemplate\": \"/{everything}\",          \"DownstreamScheme\": \"https\",          \"SwaggerKey\": \"location\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": \"7003\"            }          ],          \"UpstreamPathTemplate\": \"/location/{everything}\",          \"UpstreamHttpMethod\": [            \"GET\",            \"POST\",            \"PUT\",            \"DELETE\"          ]        }      ]    }ocelot.ordering.api.json    {      \"Routes\": [        {          \"DownstreamPathTemplate\": \"/{everything}\",          \"DownstreamScheme\": \"https\",          \"SwaggerKey\": \"ordering\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": \"7126\"            }          ],          \"UpstreamPathTemplate\": \"/ordering/{everything}\",          \"UpstreamHttpMethod\": [            \"GET\",            \"POST\",            \"PUT\",            \"DELETE\"          ]        }      ]    }ocelot.global.json    {      \"GlobalConfiguration\": {        \"BaseUrl\": \"http://localhost:5205\"      }    }ocelot.SwaggerEndPoints.json    {      \"SwaggerEndPoints\": [        {          \"Key\": \"bffweb\",          \"TransformByOcelotConfig\": false,          \"Config\": [            {              \"Name\": \"BFF.Web\",              \"Version\": \"1.0\",              \"Url\": \"http://localhost:5205/swagger/v1/swagger.json\"            }          ]        },        {          \"Key\": \"location\",          \"TransformByOcelotConfig\": true,          \"Config\": [            {              \"Name\": \"Location.API\",              \"Version\": \"1.0\",              \"Url\": \"http://localhost:5205/location/swagger/v1/swagger.json\"            }          ]        },        {          \"Key\": \"catalog\",          \"TransformByOcelotConfig\": true,          \"Config\": [            {              \"Name\": \"Catalog.API\",              \"Version\": \"1.0\",              \"Url\": \"http://localhost:5205/catalog/swagger/v1/swagger.json\"            }          ]        },        {          \"Key\": \"ordering\",          \"TransformByOcelotConfig\": true,          \"Config\": [            {              \"Name\": \"Ordering.API\",              \"Version\": \"1.0\",              \"Url\": \"http://localhost:5205/catalog/swagger/v1/swagger.json\"            }          ]        }      ]    }  Add AlterUpstream Class in Config FolderAlterUpstream.cs    using Newtonsoft.Json;    using Newtonsoft.Json.Linq;        namespace BFF.Web.Config    {        public class AlterUpstream        {            public static string AlterUpstreamSwaggerJson(HttpContext context, string swaggerJson)            {                var swagger = JObject.Parse(swaggerJson);                // ... alter upstream json                return swagger.ToString(Formatting.Indented);            }        }    }  Modify Program.cs file as followsProgram.cs    using BFF.Web.Config;    using MMLib.SwaggerForOcelot.DependencyInjection;    using Ocelot.DependencyInjection;    using Ocelot.Middleware;    using Ocelot.Provider.Polly;        var builder = WebApplication.CreateBuilder(args);        var routes = \"Routes\";        builder.Configuration.AddOcelotWithSwaggerSupport(options =&gt;    {        options.Folder = routes;    });        builder.Services.AddOcelot(builder.Configuration).AddPolly();    builder.Services.AddSwaggerForOcelot(builder.Configuration);        var environment = Environment.GetEnvironmentVariable(\"ASPNETCORE_ENVIRONMENT\");    builder.Configuration.SetBasePath(Directory.GetCurrentDirectory())        .AddOcelot(routes, builder.Environment)        .AddEnvironmentVariables();            // Add services to the container.        builder.Services.AddControllers();    // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle    builder.Services.AddEndpointsApiExplorer();        // Swagger for ocelot    builder.Services.AddSwaggerGen();        var app = builder.Build();        // Configure the HTTP request pipeline.    if (app.Environment.IsDevelopment())    {        app.UseSwagger();    }            app.UseHttpsRedirection();        app.UseAuthorization();        app.UseSwaggerForOcelotUI(options =&gt;    {        options.PathToSwaggerGenerator = \"/swagger/docs\";        options.ReConfigureUpstreamSwaggerJson = AlterUpstream.AlterUpstreamSwaggerJson;        }).UseOcelot().Wait();        app.MapControllers();        app.Run();Step 7: Run and Test application  Now run multiple (all) projects and test application using postman.  Check all end point using api gateway and swagger using the following URLhttps://localhost:7205/swagger/index.html  Select Swagger definition from top right corner of BFFSource code"
  },
  
  {
    "title": "Create .Net custom template using GitHub Packages Registry",
    "url": "/posts/Create-.Net-custom-template-using-GitHub-Packages-Registry/",
    "categories": "NugetPackage, GitHub",
    "tags": "microsoft, csharp, c#, github, nugetpackage, aspnetcore",
    "date": "2023-08-21 00:00:00 +0200",
    





    
    "snippet": "Introduction.NET gives us opportunity to create custom template for future use and GitHub packages registry is most popular now a days to host custom template. In this article, I will show you how ...",
    "content": "Introduction.NET gives us opportunity to create custom template for future use and GitHub packages registry is most popular now a days to host custom template. In this article, I will show you how to create .net custom template using GitHub packages registry.Tools and Technology uses  Visual Studio 2022  .NET 6  C#  GitHubImplementationStep 1: Create a personal access token (PAT) from GitHub  Login into you GitHub  Go to settings -&gt; Developer Settings -&gt; Personal Access Tokens  Click “Generate new token” button  Type Note for the token, expiration days      Select scope for the token – here I have selected repo, write:packages, delete:packages as shown below.        Now click “Generate Token” at the bottom of the panel      Copy the token and store the token for further use because you cannot find it later      Step 2: Add Nuget Source in visual studio  Type the following command to add sourcedotnet nuget add source https://nuget.pkg.github.com/hbolajraf/index.json --name github-hbolajraf --username hbolajraf --password &lt;Your personal Access Token&gt;      You will see a source is added in C:\\Users\\hbolajraf\\AppData\\Roaming\\NuGet\\NuGet.Config file    You can add source from visual studio Tools -&gt; Options -&gt; NuGet Package Manager -&gt; Package Sources  Restart visual studio to get new nuget package sourceStep 3: Create template for your application  Create a project or multiple projects using a solution file.  Here, I have created a clean architecture template with a solution file and multiple projects      Create a folder name – “.template.config” in the root directory of your application.        Create a file template.json in .template.config folder.  Add the following content to template.json filetemplate.json    {      \"$schema\": \"http://json.schemastore.org/template\",      \"author\": \"hbolajraf Hasan\",      \"classifications\": [        \"dotnet\",        \"CleanArchitecture\"      ],      \"name\": \"Clean Architecture project template\",      \"description\": \"Project template to create project using Clean Architecture\",      \"identity\": \"CleanArchitecture\",      \"shortName\": \"CleanArchitecture\",      \"sourceName\": \"CleanArch\",      \"tags\": {        \"language\": \"C#\",        \"type\": \"project\"      },      \"symbols\": {        \"Framework\": {          \"type\": \"parameter\",          \"description\": \"The target framework for the project.\",          \"datatype\": \"choice\",          \"choices\": [            {              \"choice\": \"net6.0\"            },            {              \"choice\": \"net5.0\"          }          ],          \"defaultValue\": \"net6.0\",          \"replaces\": \"{TargetFramework}\"        }      }    }Step 4: Install and create template locally (Optional)  Go to one where “.template.config” folder exists.  Now run the following command. Don’t forgot to add space “.” at the end.dotnet new --install .  You will see in the output that template is created. You will see Short Name of template which is used to install template.  Now go to the directory where you want to install template and type the following command.dotnet new CleanArchitecture    #or,dotnet new CleanArchitecture --forceHere CleanArchitecture is short name of the template  To create template by another name type as follows.dotnet new CleanArchitecture -o LocationNow projects name will be Location instead of CleanArch as mentioned in the previous json file.  Now go to the same directory to uninstall the template and type the following command.dotnet new --uninstall .```console    ## Step 5: Packing a template into a NuGet Package (nupkg file)*   Create a .csproj file one directory up of “.template.config” folder.*   In my case the folder structure as follows        ![](/posts/2022/temp-04.PNG)    **Add the following content in TemplatePack.csproj project.****TemplatePack.csproj**```xml         &lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt;           &lt;PropertyGroup&gt;             &lt;PackageType&gt;Template&lt;/PackageType&gt;             &lt;PackageVersion&gt;1.0.0&lt;/PackageVersion&gt;             &lt;PackageId&gt;hbolajraf.CleanArchitecture.Templates&lt;/PackageId&gt;             &lt;Title&gt;Clean Architecture Template&lt;/Title&gt;             &lt;Authors&gt;hbolajraf Hasan&lt;/Authors&gt;             &lt;Description&gt;Clean Architecture Template&lt;/Description&gt;             &lt;PackageTags&gt;dotnet-new;templates;clean-architecture&lt;/PackageTags&gt;            &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;             &lt;IncludeContentInPack&gt;true&lt;/IncludeContentInPack&gt;             &lt;IncludeBuildOutput&gt;false&lt;/IncludeBuildOutput&gt;             &lt;ContentTargetFolders&gt;content&lt;/ContentTargetFolders&gt;             &lt;NoWarn&gt;$(NoWarn);NU5128&lt;/NoWarn&gt;             &lt;NoDefaultExcludes&gt;true&lt;/NoDefaultExcludes&gt;         &lt;RepositoryUrl&gt;https://github.com/hbolajraf/public-packages&lt;/RepositoryUrl&gt;          &lt;/PropertyGroup&gt;           &lt;ItemGroup&gt;         &lt;Content Include=\"CleanArchitecture\\**\\*\" Exclude=\"CleanArchitecture\\**\\bin\\**;CleanArchitecture\\**\\obj\\**\" /&gt;         &lt;Compile Remove=\"..\\**\\*\" /&gt;           &lt;/ItemGroup&gt;       &lt;/Project&gt;   To create package go to the directory where TemplatePack.csproj file exists and type the following command.dotnet pack  You will hbolajraf.CleanArchitecture.Templates.1.0.0.nupkg file is created in bin/Debug folder.Step 6: Now push the package to github package registry  Go to the directory where hbolajraf.CleanArchitecture.Templates.1.0.0.nupkg is exists.      Type the following command to push the package in github package registry    dotnet nuget push .\\hbolajraf.CleanArchitecture.Templates.1.0.0.nupkg –api-key  --source github-hbolajraf    Here, “github-hbolajraf” is a github source which we have added in step – 2.  Now login your github and you will see a template is uploaded to your package registry.Step 7: Download template and install in local machine  Run the following command to install in local machinedotnet new --install  hbolajraf.CleanArchitecture.Templateshbolajraf.CleanArchitecture.Templates is package Id.output:The following template packages will be installed:   hbolajraf.CleanArchitecture.TemplatesSuccess: hbolajraf.CleanArchitecture.Templates::1.0.0 installed the following templates:Template Name                        Short Name         Language  Tags-----------------------------------  -----------------  --------  ------------------------Clean Architecture project template  CleanArchitecture  [C#]      dotnet/CleanArchitecture  Now go to the directory where you want to regenerate the template and type the following command.dotnet new CleanArchitectureHere CleanArchitecture is the short name of the templateNote  To see installed template in locally use the following command. You will also see how to uninstall the particular template.dotnet new --uninstall  To uninstall a particular template from local machine, use the following command.dotnet new --uninstall hbolajraf.CleanArchitecture.Templatesdotnet new –uninstall &lt;package id&gt; Source code"
  },
  
  {
    "title": "Deploy .net core NuGet Packages in GitHub Packages Registry",
    "url": "/posts/Deploy-.net-core-NuGet-Packages-in-GitHub-Packages-Registry/",
    "categories": "NugetPackage, GitHub",
    "tags": "microsoft, csharp, c#, nuget, nugetpackage, aspnetcore, github",
    "date": "2023-08-19 00:00:00 +0200",
    





    
    "snippet": "IntroductionGitHub packages registries is most popular now a days. It offers different packages registries for most used package managers, such as NuGet, npm, Docker etc. In this article, I will sh...",
    "content": "IntroductionGitHub packages registries is most popular now a days. It offers different packages registries for most used package managers, such as NuGet, npm, Docker etc. In this article, I will show you how to host a .net core NuGet Package in GitHub Packages Registry.Tools and Technology uses  Visual Studio 2022  .NET 6  C#  GitHubImplementationStep 1: Create a personal access token (PAT) from GitHub  Login into you GitHub  Go to settings -&gt; Developer Settings -&gt; Personal Access Tokens  Click “Generate new token” button  Type Note for the token, expiration days      Select scope for the token – here I have selected repo, write:packages, delete:packages as shown below.        Now click “Generate Toke” at the bottom of the panel      Copy the token and store the token for further use because you cannot find it later      Step 2: Add Nuget Source in visual studio  Type the following command to add sourcedotnet nuget add source https://nuget.pkg.github.com/hbolajraf/index.json --name github-hbolajraf --username hbolajraf --password &lt;Your personal Access Token&gt;      You will see a source is added in C:\\Users\\hbolajraf\\AppData\\Roaming\\NuGet\\NuGet.Config file    Optional: You can also add source from visual studio Tools -&gt; Options -&gt; NuGet Package Manager -&gt; Package Sources  Restart visual studio to get new nuget package sourceStep 3: Create a class library to publish in GitHub Packages  Create a class library name – ‘CryptoEngine”  Create a class CryptoGenerator as follows    using System.Security.Cryptography;    using System.Text;        namespace CryptoEngine    {        public class CryptoGenerator        {            public static string GenerateSha256Hash(string plainText)            {                // Create a SHA256                   using (SHA256 sha256Hash = SHA256.Create())                {                    // ComputeHash - returns byte array                      byte[] bytes = sha256Hash.ComputeHash(Encoding.UTF8.GetBytes(plainText));                        // Convert byte array to a string                       StringBuilder builder = new StringBuilder();                    for (int i = 0; i &lt; bytes.Length; i++)                    {                        builder.Append(bytes[i].ToString(\"x2\"));                    }                    return builder.ToString();                }            }        }    }  Click right button on class library project -&gt; Package -&gt; General  Mark “Produce a package file during build operations”  Type Package ID, Package Version, Authors, Company, Product, Description  Type repository URL – A github repository and save  Now you will see the csproj file as followsCryptoEngine.csproj    &lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt;          &lt;PropertyGroup&gt;        &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;        &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;        &lt;Nullable&gt;enable&lt;/Nullable&gt;        &lt;GeneratePackageOnBuild&gt;True&lt;/GeneratePackageOnBuild&gt;        &lt;PackageId&gt;hbolajraf.CryptoEngine&lt;/PackageId&gt;        &lt;Version&gt;1.0.0&lt;/Version&gt;        &lt;Authors&gt;hbolajraf hasan&lt;/Authors&gt;        &lt;Company&gt;hbolajraf.NET&lt;/Company&gt;        &lt;Product&gt;CryptoEngine&lt;/Product&gt;        &lt;Description&gt;Chipper text generator&lt;/Description&gt;        &lt;RepositoryUrl&gt;https://github.com/hbolajraf/public-packages&lt;/RepositoryUrl&gt;      &lt;/PropertyGroup&gt;        &lt;/Project&gt;Step 4: Create a NuGet Package  Click right button on project and select Pack  A NuGet package will be generated in bin/Debug folder – In this case the nuget package name is hbolajraf.CryptoEngine.1.0.0.nupkg  Or, Go to the directory where .csproj file exists and right the following command to generate nuget packagedotnet packStep 5: Push NuGet package to GitHub Package Registry  Go to the directory where package generated – bin/Debug in this case.  Type following commanddotnet nuget push .\\hbolajraf.CryptoEngine.1.0.0.nupkg --api-key &lt;your github access token&gt; --source github-hbolajrafHere github-hbolajraf is my nuget source name for visual studio. Already added in step 2.  Now login to your Github account and go to Packages tab, you will see a package is uploaded. In this case package name is hbolajraf.CryptoEngineStep 6: Use already uploaded package in a project  If Nuget package source is not added, add it using step – 2  Go to package manager console  Select Package Source as “github-hbolajraf” and type following commandPM&gt; Install-Package hbolajraf.CryptoEngine  Or right button on project -&gt; Manage Nuget Packages  Select Package source “github-hbolajraf”  Browse and install package hbolajraf.CryptoEngineSource code"
  },
  
  {
    "title": "Create Nuget Package using .NET Standard",
    "url": "/posts/Create-Nuget-Package-using-.NET-Standard/",
    "categories": "NugetPackage, C#",
    "tags": "microsoft, csharp, c#, nuget, nugetpackage",
    "date": "2023-08-17 00:00:00 +0200",
    





    
    "snippet": "Tools and technologies used  Visual Studio 2022  .NET Standard 2.1  Nuget.exeImplementationNew Project CreationUnder Visual Studio create a new Project Class Library and use .NET Standard 2.1 as ta...",
    "content": "Tools and technologies used  Visual Studio 2022  .NET Standard 2.1  Nuget.exeImplementationNew Project CreationUnder Visual Studio create a new Project Class Library and use .NET Standard 2.1 as target framework due to compatibility reason with latests versions of .NET CORE Frameworks.Use Nuget CLI to generate files1.Download Nuget.exe fileUse the following link to download the latests version of Nuget.exe file.2.Generate nuspec file Under the new project folder created befor, open a cmd console and run the comand bellow in order to generate the nuspec file.nuget spec NewProjectName.csprojThe result of the command should generate a new file which has the content below :&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;package &gt;  &lt;metadata&gt;    &lt;id&gt;$id$&lt;/id&gt;    &lt;version&gt;$version$&lt;/version&gt;    &lt;title&gt;$title$&lt;/title&gt;    &lt;authors&gt;$author$&lt;/authors&gt;    &lt;requireLicenseAcceptance&gt;false&lt;/requireLicenseAcceptance&gt;    &lt;license type=\"expression\"&gt;MIT&lt;/license&gt;    &lt;!-- &lt;icon&gt;icon.png&lt;/icon&gt; --&gt;    &lt;projectUrl&gt;http://project_url_here_or_delete_this_line/&lt;/projectUrl&gt;    &lt;description&gt;$description$&lt;/description&gt;    &lt;releaseNotes&gt;Summary of changes made in this release of the package.&lt;/releaseNotes&gt;    &lt;copyright&gt;$copyright$&lt;/copyright&gt;    &lt;tags&gt;Tag1 Tag2&lt;/tags&gt;  &lt;/metadata&gt;&lt;/package&gt;3.Generate nupkg fileYou have two solutions order to generate the nuget package file(nupkg)using the post-build event of the project  Under Visual Studio right click on the NewProjectName.crproj and select post-build event tab.After that put the command bellow and Build the solutionnuget pack \"$(ProjectPath)\" -Symbols -Properties Configuration=$(ConfigurationName) -IncludeReferencedProjects -OutputDirectory \"C:\\Dev\\nuget_packages\\NewProjectName\\\"using the Nuget CLI command  Under the cmd window tape the command bellow in order to generate the nuget packagenuget pack MyProject.csproj -properties Configuration=Release -OutputDirectory \"C:\\Dev\\nuget_packages\\NewProjectName\\\"In all cases the new nuget package file will be generated under the output directory : *C:\\Dev\\nuget_packages\\NewProjectName*What next ?Once you’ve created a package, which is a .nupkg file, you can publish it to the gallery of your choice(Artifactory, Azure artifacts or GitHub Package registry)"
  }
  
]

