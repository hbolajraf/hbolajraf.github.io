[
  
  {
    "title": "Docker Tips and Tricks",
    "url": "/posts/Docker-Tips-and-Tricks/",
    "categories": "Tips And Tricks, Docker",
    "tags": "microsoft, docker, tips&tricks",
    "date": "2023-10-26 00:00:00 +0200",
    





    
    "snippet": "Docker is a powerful tool for containerization, allowing you to package and run applications with their dependencies in isolated containers. Here are some tips and tricks for using Docker effective...",
    "content": "Docker is a powerful tool for containerization, allowing you to package and run applications with their dependencies in isolated containers. Here are some tips and tricks for using Docker effectively.Installation and Setup1. Install Docker  To get started, install Docker by following the official installation instructions for your operating system on the Docker website.2. Use Docker Compose  Docker Compose is a tool for defining and running multi-container Docker applications. It simplifies the process of managing complex applications with multiple containers.Basic Docker Commands3. Pull an Image  Use docker pull to download Docker images from a registry. For example, docker pull ubuntu will pull the Ubuntu image.4. List Images  To list all downloaded images, use docker images or docker image ls.5. Run a Container  Start a new container with docker run. For example, docker run -it ubuntu bash runs an interactive Ubuntu container.6. Attach to a Running Container  To attach to a running container, use docker exec -it &lt;container_name&gt; bash.7. Stop and Remove Containers  Use docker stop &lt;container_id&gt; to stop a running container. To remove a stopped container, use docker rm &lt;container_id&gt;.8. View Container Logs  View container logs with docker logs &lt;container_id&gt;.9. Naming Containers  When running containers, provide a --name flag to give them human-readable names.Advanced Docker Commands10. Build a Docker Image  Create a Docker image from a Dockerfile using docker build. For example, docker build -t my-image:1.0 . builds an image from the current directory.11. Docker Registry Login  Log in to a Docker registry using docker login. This is necessary for pushing images to a private registry.12. Push Images to a Registry  Push your Docker images to a registry with docker push. For example, docker push my-image:1.0 pushes an image to the registry.13. Docker Network  Create custom Docker networks to connect containers. Use docker network create to create a network and --network to specify it when running containers.14. Volume Mounting  Share data between your host and container by using volume mounts with the -v or --volume flag. For example, docker run -v /host/path:/container/path.15. Docker Compose for Multi-Container Apps  Use a docker-compose.yml file to define and run multi-container applications. Run them with docker-compose up.Docker Security16. Limit Container Capabilities  Reduce a container‚Äôs capabilities by using the --cap-drop and --cap-add flags in the docker run command.17. Scan Images for Vulnerabilities  Utilize tools like Clair or Trivy to scan your Docker images for known vulnerabilities before deploying them.18. Regularly Update Images  Keep your base images up to date, as they may contain security patches. Use the latest base images from the official repositories.Docker Cleanup19. Remove Dangling Images  Remove unused images with docker image prune.20. Clean Up Containers  Remove all stopped containers with docker container prune.What Next?  Remember to consult the Docker documentation and community resources for additional tips and best practices when working with Docker containers."
  },
  
  {
    "title": "Git | Tips and Tricks",
    "url": "/posts/Git-Tips-and-Tricks/",
    "categories": "GitHub, Git",
    "tags": "git, github, sourcecontrol",
    "date": "2023-10-01 00:00:00 +0200",
    





    
    "snippet": "Git Tips and TricksGit is a powerful version control system that can make your development workflow more efficient. Here are some tips and tricks to help you get the most out of Git.Configure GitBe...",
    "content": "Git Tips and TricksGit is a powerful version control system that can make your development workflow more efficient. Here are some tips and tricks to help you get the most out of Git.Configure GitBefore you start using Git, it‚Äôs a good idea to configure it with your name and email address. This information will be associated with your commits.git config --global user.name \"hbolajraf\"git config --global user.email \"hassan.bolajraf@gmail.com\"You can also set other configurations, such as your preferred text editor and default branch.Basic Commands1. Initialize a Repository: To start a new Git repository, use git init in your project directory.2. Clone a Repository: To clone a repository from a remote URL, use git clone &lt;URL&gt;.3. Commit Changes: After making changes, use git commit -m \"Your commit message\" to save them.4. Check the Status: Use git status to see the status of your working directory.BranchingBranches are essential for managing different lines of development.1. Create a Branch: Use git branch &lt;branch_name&gt; to create a new branch.2. Switch Branches: To switch to a different branch, use git checkout &lt;branch_name&gt;.3. Merge Branches: Merge changes from one branch into another with git merge &lt;branch_name&gt;.4. Delete Branch: Use git branch -d &lt;branch_name&gt; to delete a branch.StashingStashing is useful when you need to save your changes temporarily.1. Stash Changes: Use git stash to save your changes.2. Apply Stash: To reapply your changes, use git stash apply.3. List Stashes: See a list of stashes with git stash list.Interactive RebaseInteractive rebase allows you to modify commit history.1. Rebase Interactive: Use git rebase -i HEAD~n to interactively rebase the last n commits.2. Edit Commits: Change ‚Äúpick‚Äù to ‚Äúedit‚Äù to modify a commit.3. Amend Commits: Use git commit --amend to edit the current commit.Git AliasesGit aliases let you create shortcuts for Git commands.1. Create an Alias: Add an alias to your global Git configuration.git config --global alias.co checkout2. Usage: Now, you can use git co as a shorthand for git checkout.Git HooksGit hooks are scripts that run automatically on certain Git events.1. Pre-Commit Hook: Create a .git/hooks/pre-commit script to run actions before a commit.2. Post-Receive Hook: In a server‚Äôs Git repository, create a hooks/post-receive script to perform actions after receiving a push.Ignoring FilesYou can specify files or patterns to ignore using a .gitignore file.1. Create .gitignore: Create a file named .gitignore and list the files, directories, or patterns you want to ignore.2. Example .gitignore:# Ignore build artifactsbin/obj/# Ignore log files*.log# Ignore a specific directorydocs/What Next?These tips and tricks will help you become more proficient with Git, making your version control tasks more efficient and your development process smoother."
  },
  
  {
    "title": "Configure QoS within API Gateway using ocelot and Polly",
    "url": "/posts/Configure-QoS-within-API-Gateway-using-ocelot-and-Polly/",
    "categories": "Microservices, Ocelot",
    "tags": "microsoft, aspnetcore, csharp, microservices, ocelot, polly, webapi, c#, gateway, qos",
    "date": "2023-09-27 00:00:00 +0200",
    





    
    "snippet": "IntroductionAPI Gateway is an entry point for backend application. It maintains routing, authentication, logging, service discovery etc. Ocelot is used to design and develop API gateway for .net ba...",
    "content": "IntroductionAPI Gateway is an entry point for backend application. It maintains routing, authentication, logging, service discovery etc. Ocelot is used to design and develop API gateway for .net based application. QoS is generally configured in API gateway which provides different priorities for different applications, users or traffic. In this article, we will configure and discuss Quality of Services (QoS) using ocelot and Polly on ASP.NET Core web API project.What is Quality of Service (QoS)?QoS provides different priorities to different applications, users or data flow. We have already mentioned, Ocelot is used to design API Gateway and Ocelot uses Polly to achieve QoS.The QoSOptions node contains three important properties.      ExceptionsAllowedBeforeBreakingThis value must greater than 0. It means that the circuit breaker will break after a certain number of exceptions occur. For example:        DurationOfBreakThis value specifies how long the circuit breaker will stay open after it is tripped. The unit of this value is milliseconds. For example: 5000 means 5 seconds        TimeoutValueThis value specifies that a request will automatically be timed out if it takes more than this value. The unit of this value is milliseconds as well. For example: 3000 means 3 seconds.  Tools and Technology used  Visual Studio 2022  .NET 6.0  In Memory Database  Entity Framework  ASP.NET Core Web API  C#  Ocelot and  MMLib.SwaggerForOcelotImplementationStep 1: Create solution and projects.  Create a solution name QoS.  Add 2 new web api projects, name ‚Äì Catalog.API, BFF.WebHere, BFF.Web project will act as API Gateway.Step 2: Install nuget packages.  Install following nuget packages in Catalog.API    PM&gt; Install-Package Microsoft.EntityFrameworkCore.InMemory    PM&gt; Install-Package Microsoft.EntityFrameworkCore.SqlServer    PM&gt; Install-Package Microsoft.EntityFrameworkCore.Tools    PM&gt; Install-Package Microsoft.VisualStudio.Web.CodeGeneration.Design      Install following nuget packages in BFF.Web    PM&gt; Install-Package MMLib.SwaggerForOcelot    PM&gt; Install-Package Ocelot    PM&gt; Install-Package Ocelot.Provider.PollyStep 3: Organize Catalog.API  Create CatalogItem model in Model folderCatalogItem.cs    using System.ComponentModel.DataAnnotations;    using System.ComponentModel.DataAnnotations.Schema;        namespace Catalog.API.Model    {        public class CatalogItem        {            [Key]            [DatabaseGenerated(DatabaseGeneratedOption.Identity)]            public int Id { get; set; }            public string Name { get; set; }                public string Description { get; set; }                public decimal Price { get; set; }                public int AvailableStock { get; set; }                public int RestockThreshold { get; set; }        }    }  Create DbContext class as CatalogContext in Db folderCatalogContext.cs    using Catalog.API.Model;    using Microsoft.EntityFrameworkCore;        namespace Catalog.API.Db    {        public class CatalogContext : DbContext        {            public CatalogContext(DbContextOptions&lt;CatalogContext&gt; options) : base(options)            {                }                protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)            {                base.OnConfiguring(optionsBuilder);            }                public DbSet&lt;CatalogItem&gt; CatalogItems { get; set; }        }    }  Create SeedDataProvider class in Db folderSeedDataProvider.cs    using Catalog.API.Model;        namespace Catalog.API.Db    {        public class SeedDataProvider        {            public static void Initialize(CatalogContext catalogContext)            {                if(!catalogContext.CatalogItems.Any())                {                    var catalogs = new List&lt;CatalogItem&gt;                    {                        new CatalogItem                        {                            Name = \"T-Shirt\",                            Description = \"Cats Eye T-Shirt\",                            Price = 1000,                            AvailableStock = 100,                            RestockThreshold = 10                        },                            new CatalogItem                        {                            Name = \"Samsung Mobile\",                            Description = \"Samsung A30\",                            Price = 30000,                            AvailableStock = 100,                            RestockThreshold = 5                        },                            new CatalogItem                        {                            Name = \"Meril Beauty Soap\",                            Description = \"Beauty Soap\",                            Price = 40,                            AvailableStock = 500,                            RestockThreshold = 20                        }                    };                        catalogContext.CatalogItems.AddRange(catalogs);                    catalogContext.SaveChanges();                }            }        }    }  Modify Program class as follows.Program.cs    using Catalog.API.Db;    using Microsoft.EntityFrameworkCore;        var builder = WebApplication.CreateBuilder(args);        // Add services to the container.        builder.Services.AddControllers();        builder.Services.AddDbContext&lt;CatalogContext&gt;(opt =&gt; opt.UseInMemoryDatabase(\"CatalogDB\"));        // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle    builder.Services.AddEndpointsApiExplorer();    builder.Services.AddSwaggerGen();        var app = builder.Build();        // For Seed data generation    using(var scope = app.Services.CreateScope())    {        var services = scope.ServiceProvider;        var db = services.GetRequiredService&lt;CatalogContext&gt;();        SeedDataProvider.Initialize(db);    }        // Configure the HTTP request pipeline.    if (app.Environment.IsDevelopment())    {        app.UseSwagger();        app.UseSwaggerUI();    }        app.UseHttpsRedirection();        app.UseAuthorization();        app.MapControllers();        app.Run();Here, the following line is used to configure in memory database    builder.Services.AddDbContext&lt;CatalogContext&gt;(opt =&gt; opt.UseInMemoryDatabase(\"CatalogDB\"));The following code snippet is used to initialize seed data    using(var scope = app.Services.CreateScope())    {        var services = scope.ServiceProvider;        var db = services.GetRequiredService&lt;CatalogContext&gt;();        SeedDataProvider.Initialize(db);    }  Add CatalogItemsController class in Controllers folder as follows.CatalogItemsController.cs    using Catalog.API.Db;    using Catalog.API.Model;    using Microsoft.AspNetCore.Mvc;    using Microsoft.EntityFrameworkCore;        namespace Catalog.API.Controllers    {        [Route(\"api/[controller]\")]        [ApiController]        public class CatalogItemsController : ControllerBase        {            private readonly CatalogContext _context;            private static int _count = 0;                public CatalogItemsController(CatalogContext context)            {                _context = context;            }                // GET: api/CatalogItems            [HttpGet]            public async Task&lt;ActionResult&lt;IEnumerable&lt;CatalogItem&gt;&gt;&gt; GetCatalogItems()            {                _count++;                if(_count &lt;= 3)                {                    // Sleep for 4 seconds                    Thread.Sleep(4000);                }                    if (_context.CatalogItems == null)                {                    return NotFound();                }                return await _context.CatalogItems.ToListAsync();            }                // GET: api/CatalogItems/5            [HttpGet(\"{id}\")]            public async Task&lt;ActionResult&lt;CatalogItem&gt;&gt; GetCatalogItem(int id)            {                if (_context.CatalogItems == null)                {                    return NotFound();                }                var catalogItem = await _context.CatalogItems.FindAsync(id);                    if (catalogItem == null)                {                    return NotFound();                }                    return catalogItem;            }                // PUT: api/CatalogItems/5            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPut(\"{id}\")]            public async Task&lt;IActionResult&gt; PutCatalogItem(int id, CatalogItem catalogItem)            {                if (id != catalogItem.Id)                {                    return BadRequest();                }                    _context.Entry(catalogItem).State = EntityState.Modified;                    try                {                    await _context.SaveChangesAsync();                }                catch (DbUpdateConcurrencyException)                {                    if (!CatalogItemExists(id))                    {                        return NotFound();                    }                    else                    {                        throw;                    }                }                    return NoContent();            }                // POST: api/CatalogItems            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPost]            public async Task&lt;ActionResult&lt;CatalogItem&gt;&gt; PostCatalogItem(CatalogItem catalogItem)            {                if (_context.CatalogItems == null)                {                    return Problem(\"Entity set 'CatalogContext.CatalogItems'  is null.\");                }                _context.CatalogItems.Add(catalogItem);                await _context.SaveChangesAsync();                    return CreatedAtAction(\"GetCatalogItem\", new { id = catalogItem.Id }, catalogItem);            }                // DELETE: api/CatalogItems/5            [HttpDelete(\"{id}\")]            public async Task&lt;IActionResult&gt; DeleteCatalogItem(int id)            {                if (_context.CatalogItems == null)                {                    return NotFound();                }                var catalogItem = await _context.CatalogItems.FindAsync(id);                if (catalogItem == null)                {                    return NotFound();                }                    _context.CatalogItems.Remove(catalogItem);                await _context.SaveChangesAsync();                    return NoContent();            }                private bool CatalogItemExists(int id)            {                return (_context.CatalogItems?.Any(e =&gt; e.Id == id)).GetValueOrDefault();            }        }    }Step 4: Organize BFF.WebIn this stage, we are going to configure a gateway to communicate with other services using ocelot.      Create a folder name - Routes.dev in root directory and add the following files. ocelot.catalog-api.json, ocelot.global.json, ocelot.SwaggerEndPoints.json in Routes.dev folder.        Now modify the json files as follows.  ocelot.catalog-api.json    {      \"Routes\": [        {          \"DownstreamPathTemplate\": \"/{everything}\",          \"DownstreamScheme\": \"https\",          \"SwaggerKey\": \"catalog-api\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": \"7282\"            }          ],          \"UpstreamPathTemplate\": \"/catalog/{everything}\",          \"UpstreamHttpMethod\": [            \"GET\",            \"POST\",            \"PUT\",            \"DELETE\"          ],              \"QoSOptions\": {            \"ExceptionsAllowedBeforeBreaking\": 2,            \"DurationOfBreak\": 5000,            \"TimeoutValue\": 3000          }            }      ]    }QoSOptions section of the above file basically configure QoS for Catalog service. The above configuration means that if the server does not response for 3 minutes, it will throw timeout exception. If the server throws two exceptions, it will not be accessible for five minutes.ocelot.global.json    {      \"GlobalConfiguration\": {        \"BaseUrl\": \"https://localhost:7205\"        //\"ServiceDiscoveryProvider\": {            //  \"Host\": \"localhost\",        //  \"Port\": 7205        //}      }    }ocelot.SwaggerEndPoints.json    {      \"SwaggerEndPoints\": [        {          \"Key\": \"bffweb\",          \"TransformByOcelotConfig\": false,          \"Config\": [            {              \"Name\": \"BFF.Web\",              \"Version\": \"1.0\",              \"Url\": \"https://localhost:7205/swagger/v1/swagger.json\"            }          ]        },            {          \"Key\": \"catalog-api\",          \"TransformByOcelotConfig\": true,          \"Config\": [            {              \"Name\": \"Catalog.API\",              \"Version\": \"1.0\",              \"Url\": \"https://localhost:7205/catalog/swagger/v1/swagger.json\"            }          ]        }      ]    }Note: I have added the following code block in CatalogItemController to produce timeout manually.            [HttpGet]            public async Task&lt;ActionResult&lt;IEnumerable&lt;CatalogItem&gt;&gt;&gt; GetCatalogItems()            {                _count++;                if(_count &lt;= 3)                {                    // Sleep for 4 seconds                    Thread.Sleep(4000);                }                    if (_context.CatalogItems == null)                {                    return NotFound();                }                return await _context.CatalogItems.ToListAsync();            }Step 5: Run and test the applicationNow run both web projects. In the BFF.Web, select Catalog.API-1.0 from swagger definition (‚ÄúSelect a definition on the top right corner‚Äù) and execute the api (CatalogItems) as follows.When we visit the first time (or quickly second time), it tells us that circuit is breaking for 5000 ms. Look at the console of BFF.Web.Then, the second time (quickly) it tells us that the circuit is open, and we cannot visit the service for 3 seconds as follows.After 3 seconds, the service is accessible. If you execute now, you will see the output like below.Source code"
  },
  
  {
    "title": "Search AD entry by ObjectSid using Novell Directory Ldap Nuget package",
    "url": "/posts/Search-AD-entry-by-ObjectSid-using-Novell-Directory-Ldap-Nuget-package/",
    "categories": "ActiveDirectory, Ldap",
    "tags": "ldap, microsoft, c#, dotnet, activedirectory",
    "date": "2023-09-25 00:00:00 +0200",
    





    
    "snippet": "SID stands for security identifier, a unique string that Windows Server automatically assigns to each computer, user and group in order to mark and clearly distinguish them.Windows SID Format :SIDs...",
    "content": "SID stands for security identifier, a unique string that Windows Server automatically assigns to each computer, user and group in order to mark and clearly distinguish them.Windows SID Format :SIDs always follow the same structure, with values separated by dashes:Novell Directory LdapNovell Directory Ldap nuget package allows you to connect to the active directory in order to perform CRUD actions on all AD objects, among other Users Groups and computers. it support both platforms windows and linux, so even if you are under kubernetes  clusters on docker containers you will be able to manage AD objects.C# code practical caseThis exemple is based on a project that was created based on .Net 6 under Visual studio 2022 and with a docker support to manage Ad Objects within a linux docker container.The nuget package version that was used are the following :&lt;PackageReference Include=\"Novell.Directory.Ldap.NETStandard\" Version=\"3.6.0\" /&gt;When we will process a search within the AD for a dedicated entry we will use a string ObjectSid instead of a bytes value. To do that we will create a helper method that will return the string value based on the input ObjectSid bytes value as bellow :1. Add Helper method to convert ObjectSID Byte value in string format public static string ConvertSidByteValueToStringValue(Byte[] sidBytes)        {            short sSubAuthorityCount = 0;            StringBuilder strSid = new StringBuilder();            strSid.Append(\"S-\");            try            {                // Add SID revision.                strSid.Append(sidBytes[0].ToString());                sSubAuthorityCount = Convert.ToInt16(sidBytes[1]);                // Next six bytes are SID authority value.                if (sidBytes[2] != 0 || sidBytes[3] != 0)                {                    string strAuth = String.Format(\"0x{0:2x}{1:2x}{2:2x}{3:2x}{4:2x}{5:2x}\",                                   (Int16)sidBytes[2],                                   (Int16)sidBytes[3],                                   (Int16)sidBytes[4],                                   (Int16)sidBytes[5],                                   (Int16)sidBytes[6],                                   (Int16)sidBytes[7]);                    strSid.Append(\"-\");                    strSid.Append(strAuth);                }                else                {                    Int64 iVal = sidBytes[7] +                         (sidBytes[6] &lt;&lt; 8) +                         (sidBytes[5] &lt;&lt; 16) +                         (sidBytes[4] &lt;&lt; 24);                    strSid.Append(\"-\");                    strSid.Append(iVal.ToString());                }                // Get sub authority count...                int idxAuth = 0;                for (int i = 0; i &lt; sSubAuthorityCount; i++)                {                    idxAuth = 8 + i * 4;                    UInt32 iSubAuth = BitConverter.ToUInt32(sidBytes, idxAuth);                    strSid.Append(\"-\");                    strSid.Append(iSubAuth.ToString());                }            }            catch (Exception ex)            {                Trace.TraceWarning(ex.Message);                throw;            }            return strSid.ToString();        }This method will get ObjectSid information parts from the array of Bytes input value as bellow :byte[0]      - Revision Levelbyte[1]      - count of Sub-Authoritiesbyte[2 - 7]  - 48 bit Authority(big-endian)byte[8 +]    - n Sub-Authorities, 32 bits And after that we return a String ObjectSID on the format bellow :S-{Revision}-{Authority}-{ SubAuthority1}-{ SubAuthority2}...-{ SubAuthorityN}2. Call Active Directory to retrieve User informations based on objectSid string valueAdding Novell directiveusing Novell.Directory.Ldap;.....Adding the search method to get the User entry object/// Exemple of Dn Value  : OU=User,OU=Accounts,DC=USA,DC=NY        /// Exemple of objectSidStringValue Value  : S-1-5-15-420314761-778715008-4547327-1845947        /// Exemple of objectCategory Value  : User or Group or Computer        /// Exemple of OutputProps Values : \"description\",\"lastLogon\",\"email\",\"name\", \"login\"        public List&lt;Attributes&lt;string, string&gt;&gt;? GetLdapEntryByObjectSid(string Dn, string objectSidStringValue, string objectCategory, string[] OutputProps)        {            var ldapConnectionOptions = new LdapConnectionOptions();            ldapConnectionOptions.UseSsl();            var ldapConx = new LdapConnection(ldapConnectionOptions);            List&lt;Attributes&lt;string, string&gt;&gt; listAttributes = new List&lt;Attributes&lt;string, string&gt;&gt;();            string Filter = $\"(&amp;(objectSid={objectSidStringValue})(objectCategory={objectCategory}))\";                        if (!string.IsNullOrEmpty(Filter))            {                var searchQuery = ldapConx.Search(Dn, Novell.Directory.Ldap.LdapConnection.ScopeSub, Filter, OutputProps, false);                if (searchQuery != null)                {                    while (searchQuery.HasMore())                    {                        LdapEntry nextEntry = null;                            nextEntry = searchQuery.Next();                            //SID Case                             if (OutputProps.Contains(\"objectSid\"))                            {                                //Get Sid Property Bytes value to be converted into string clear value                                var objectSid = nextEntry.GetAttributeSet().FirstOrDefault(e =&gt; e.Key.Equals(\"objectSid\"));                                if (objectSid.Value != null)                                {                                    var sidStringFormat = ConvertSidByteValueToStringValue(objectSid.Value.ByteValue);                                    listAttributes.Add(new Attributes&lt;string, string&gt;(objectSid.Key, sidStringFormat));                                }                            }                            listAttributes.AddRange(nextEntry.GetAttributeSet()                                .Where(e =&gt; !e.Key.Equals(\"objectSid\"))                                .Select(e =&gt; new Attributes&lt;string, string&gt;(e.Key, e.Value.StringValue))                                .ToList());                                           }                }            }            return listAttributes;        }The GetLdapEntryByObjectSid method will process a searchQuery within ldap based on the objectSid filter and also the objectCategory in this example User filter. As mentioned the objectSid within Active directory are persisted as a byte so we will call our Helper method to convert it into a string value: var sidStringFormat = ConvertSidByteValueToStringValue(objectSid.Value.ByteValue);The returned list of properties will contains all properties as string readable values, so we can use them also to process a new search based on other property.Links : Novell Directory - GitHub repositoryNovell Directory - Nuget package"
  },
  
  {
    "title": "AZ-400 Certification Path",
    "url": "/posts/AZ-400-Certification-Path/",
    "categories": "Microsoft, Certification",
    "tags": "certification, microsoft, azuredevops, dotnet",
    "date": "2023-09-25 00:00:00 +0200",
    





    
    "snippet": "Microsoft certification paths changesBoth the MCSD and MCT certifications were discontinued by Microsoft in 2017. They were replaced by newer certification programs that reflect the changing demand...",
    "content": "Microsoft certification paths changesBoth the MCSD and MCT certifications were discontinued by Microsoft in 2017. They were replaced by newer certification programs that reflect the changing demands of the tech industry and the evolving needs of professionals.The MCSD certification was replaced by the Azure Developer Associate certification, which is a newer certification program that is designed for developers who want to demonstrate their expertise in buildingand deploying cloud-based solutions using Microsoft Azure. The MCT certification was replaced by the Microsoft Certified: Learning Consultant certification, which is a program that recognizes individuals who have demonstrated expertise in designing and delivering training programs on Microsoft technologies.Microsoft offers a wide range of certification programs that are designed to validate the skills of professionals in a variety of different roles. Some of the most popular certification programs offered by Microsoft by role include:      Developers: Microsoft offers several certification programs that are designed for developers, including the Azure Developer Associate certification, the Microsoft Certified: Power Platform Developer Associate certification, and noth the Microsoft Certified: Azure Solutions Architect Expert certification and DevOps Engineer Expert.        IT Administrators: Microsoft offers several certification programs that are designed for IT administrators, including the Microsoft Certified: Azure Administrator Associate certification, the Microsoft Certified: Azure Security Engineer Associate certification, and the Microsoft Certified: Windows Server 2016 certification.        Data Professionals: Microsoft offers several certification programs that are designed for data professionals, including the Microsoft Certified: Data Analyst Associate certification, the Microsoft Certified: Data Scientist Associate certification, and the Microsoft Certified: Azure Data Engineer Associate certification.        Business Professionals: Microsoft offers several certification programs that are designed for business professionals, including the Microsoft Certified: Power Platform Fundamentals certification, the Microsoft Certified: Dynamics 365 Fundamentals certification, and the Microsoft Certified: Dynamics 365 Marketing certification.        Educators: Microsoft offers several certification programs that are designed for educators, including the Microsoft Certified: Educator certification, the Microsoft Certified: Trainer certification, and the Microsoft Certified: Learning Consultant certification.  We will focus in this post on Developers role. So, actually for a dotnet developer the best Microsoft certification to achieve is by following the DevOps Engineer Expert Certification path. Currently the different missions of a dotnet developer require some experience on the devops side for the build and release parts and as well as on the Microsoft Azure part too.Describe certificate pathAccording to The 2021 Pearson VUE Value of IT Certification survey 91% of certified IT professional get more professional credibility, 76% are more valuable to their employers, and 28% of the surveyed candidates reported a salary increase as a benefit of getting certified.Azure DevOps Expert Certification is a three-stars certification that falls under the Microsoft expert-level certifications.AZ-400 Exam PrerequisiteA candidate for this exam must have written either or both of the assoiate Microsoft certification in the schema bellow. Note that the Exam AZ-900: Microsoft Azure Fundamentals are optional and it open to you to pass it. From my part i choose to write the Azure Developer Associate because of my experience as a software developer. For Devops engineer it more recommended to pass the Administrator Associate certification in order to achieve the DevOps Engineer Expert one.Study for your examThe AZ-400 Exam contains about 40-60 questions; however, the number can vary depending on the exam. with a duration of about 180 minutes. Candidates are required to have a passing score of 700/1000 to earn the certification.Structure of the exam      Single-choice questions(with YES/NO options) Cannot be reviewed, skipped, or returned to later.        Single-choice questions.        Multiple-choice questions.        Arrange in the right sequence questions.        Case-study with multiple questions.  Study planA typical study plan may last for a month at about 5 hours of daily study. The study plan depends on the level of experience candidates have on the various topics measured in the exam. Experienced DevOps professionals may spend less time compared to the beginner fellows.Study materialsThis exam measures your ability to accomplish the following technical tasks: develop an instrumentation strategy; develop a Site Reliability Engineering (SRE) strategy; develop a security and compliance plan; manage source control; facilitate communication and collaboration; define and implement continuous integration; and define and implement continuous delivery and release management strategy. The following materials should be helpful.Microsoft learn: Azure DevOps Learning Path      Azure Devops Labs: get hands-on experience using various Azure DevOps services to solve real-life scenario business problems.        Azure DevOps documentation        Azure documentation        Practice question materialsThe listed links below are very helpful and may tell you what the questions may look like. All the objectives of this exam are covered so you‚Äôll be ready for any question on the exam.  AZ-400: Designing and Implementing Microsoft DevOps Solutions Microsoft Official Practice TestWhizlabs-AZ-400 Practice testExamTopics-AZ-400 Practice testScheduling and Taking your examIt is important you arrive at your test center 15-30 minutes before your scheduled appointment time. This will give you adequate time to complete the necessary sign-in procedures. If you arrive more than 15 minutes late for an exam and are refused admission, payments are due for the exam and delivery fees.Be prepared to show two (2) valid forms of personal identification, a National Identity card, Drivers license, or an International Passport.TipsMark questions whose answers you are not sure about for review, and revisit them when done with the others.Don‚Äôt leave any questions unanswered and make sure to submit before proceeding to the next section.Case-study questions come after the first section.Make sure you keep to time.You will receive your transcript upon submission in less than an hour, and an acclaim badge upon passing the exam in your mailbox. Share your badge on social networks like LinkedIn, Twitter, or Facebook.Voila, congratulations, you are now a Microsoft Certified: Azure DevOps Expert, you deserve it. Keep your skills sharp and transfer your knowledge to real work situations.Thank you for reading, I hope this helps you prepare and pass the AZ-400 examination.You can view my Azure DevOps badges here üòäMicrosoft Certified: Azure Developer AssociateMicrosoft Certified: DevOps Engineer ExpertReferenceMicrosoft Certified: DevOps Engineer ExpertAzure DevOps Labs2021 Pearson VUE Value of IT CertificationIntroduction to the AZ-400: Designing and Implementing Microsoft DevOps Solutions Exam"
  },
  
  {
    "title": "Implementing API gateway using ocelot in asp.net core application",
    "url": "/posts/Implementing-Ocelot-Gateway/",
    "categories": "Microservices, Ocelot",
    "tags": "microsoft, aspnetcore, csharp, microservices, ocelot, webapi, c#, gateway",
    "date": "2023-09-24 00:00:00 +0200",
    





    
    "snippet": "API Gateway is an API management tools that sits between a client application and backend application. It agregates different services, maintain load balancing and work as reverse proxy. Ocelot is ...",
    "content": "API Gateway is an API management tools that sits between a client application and backend application. It agregates different services, maintain load balancing and work as reverse proxy. Ocelot is an api managment tool which is very powerful and best fit for .net application.Tools and technologies used  Visual Studio 2022  .NET 6.0  In Memory Database  Entity Framework  ASP.NET Core Web API  C#  OcelotImplementationStep 1: Create solution and projects.  Create a solution name APIGateway  Add 4 new web api project, name - Catalog.API, Location.API, Ordering.API and BFF.Web in the solution.Here, BFF.Web project will act as API Gateway.Step 2: Install nuget packages.  Install following nuget package in Catalog.API Project    PM&gt; Install-Package Microsoft.EntityFrameworkCore.InMemoryPM&gt; Install-Package Microsoft.EntityFrameworkCore.SqlServerPM&gt; Install-Package Microsoft.EntityFrameworkCore.Tools        Install following nuget package in Ordering.API Project    PM&gt; Install-Package Microsoft.EntityFrameworkCorePM&gt; Install-Package Microsoft.EntityFrameworkCore.InMemoryPM&gt; Install-Package Microsoft.EntityFrameworkCore.SqlServerPM&gt; Install-Package Microsoft.EntityFrameworkCore.Tools        Install following nuget packages in BFF.Web Project    PM&gt; Install-Package OcelotPM&gt; Install-Package Ocelot.Cache.CacheManager      Step 3: Organize Catalog.API Project  Create a Product model class in Catalog.API/Model folderProduct.cs    using System.ComponentModel.DataAnnotations;    using System.ComponentModel.DataAnnotations.Schema;        namespace Catalog.API.Model    {        public class Product        {            [Key]            [DatabaseGenerated(DatabaseGeneratedOption.Identity)]            public int Id { get; set; }            public string Name { get; set; }                public string Description { get; set; }                public decimal Price { get; set; }                public int AvailableStock { get; set; }                public int RestockThreshold { get; set; }        }    }  Create a CatalogContext class in Catalog.API/Db folderCatalogContext.cs    using Catalog.API.Model;    using Microsoft.EntityFrameworkCore;        namespace Catalog.API.Db    {        public class CatalogContext : DbContext        {            public CatalogContext(DbContextOptions&lt;CatalogContext&gt; options) : base(options)            {                }                protected override void OnModelCreating(ModelBuilder modelBuilder)            {                }                protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)            {                base.OnConfiguring(optionsBuilder);            }                public DbSet&lt;Product&gt; Products { get; set; }        }    }  Modify Program.cs file as follows    using Catalog.API.Db;    using Microsoft.EntityFrameworkCore;        var builder = WebApplication.CreateBuilder(args);        // Add services to the container.        builder.Services.AddControllers();        builder.Services.AddDbContext&lt;CatalogContext&gt;(opt =&gt; opt.UseInMemoryDatabase(\"CatalogDB\"));        // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle    builder.Services.AddEndpointsApiExplorer();    builder.Services.AddSwaggerGen();        var app = builder.Build();        // Configure the HTTP request pipeline.    if (app.Environment.IsDevelopment())    {        app.UseSwagger();        app.UseSwaggerUI();    }        app.UseHttpsRedirection();        app.UseAuthorization();        app.MapControllers();        app.Run();  Create a conroller class name ProductsController in Catalog.API/Controllers folderCatalogContoller.cs    using System;    using System.Collections.Generic;    using System.Linq;    using System.Threading.Tasks;    using Microsoft.AspNetCore.Http;    using Microsoft.AspNetCore.Mvc;    using Microsoft.EntityFrameworkCore;    using Catalog.API.Db;    using Catalog.API.Model;        namespace Catalog.API.Controllers    {        [Route(\"api/[controller]\")]        [ApiController]        public class ProductsController : ControllerBase        {            private readonly CatalogContext _context;                public ProductsController(CatalogContext context)            {                _context = context;            }                // GET: api/Products            [HttpGet(\"GetAll\")]            public async Task&lt;ActionResult&lt;IEnumerable&lt;Product&gt;&gt;&gt; GetProducts()            {                return await _context.Products.ToListAsync();            }                // GET: api/Products/5            [HttpGet(\"{id}\")]            public async Task&lt;ActionResult&lt;Product&gt;&gt; GetProduct(int id)            {                var product = await _context.Products.FindAsync(id);                    if (product == null)                {                    return NotFound();                }                    return product;            }                // PUT: api/Products/5            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPut(\"Edit/{id}\")]            public async Task&lt;IActionResult&gt; PutProduct(int id, Product product)            {                if (id != product.Id)                {                    return BadRequest();                }                    _context.Entry(product).State = EntityState.Modified;                    try                {                    await _context.SaveChangesAsync();                }                catch (DbUpdateConcurrencyException)                {                    if (!ProductExists(id))                    {                        return NotFound();                    }                    else                    {                        throw;                    }                }                    return NoContent();            }                // POST: api/Products            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPost(\"Add\")]            public async Task&lt;ActionResult&lt;Product&gt;&gt; PostProduct(Product product)            {                _context.Products.Add(product);                await _context.SaveChangesAsync();                    return CreatedAtAction(\"GetProduct\", new { id = product.Id }, product);            }                // DELETE: api/Products/5            [HttpDelete(\"Delete/{id}\")]            public async Task&lt;IActionResult&gt; DeleteProduct(int id)            {                var product = await _context.Products.FindAsync(id);                if (product == null)                {                    return NotFound();                }                    _context.Products.Remove(product);                await _context.SaveChangesAsync();                    return NoContent();            }                private bool ProductExists(int id)            {                return _context.Products.Any(e =&gt; e.Id == id);            }        }    }Step 4: Organize Ordering.API Project  Create a Order model class in Ordering.API/Model folderOrder.cs    namespace Ordering.API.Models    {        public class Order        {            public int Id { get; set; }            public string Address { get; set; }                public DateTime OrderDate { get; set; }                public string Comments { get; set; }        }    }  Create a OrderingContext class in Ordering.API/Db folderOrderingContext.cs    using Microsoft.EntityFrameworkCore;    using Ordering.API.Models;        namespace Ordering.API.Db    {        public class OrderingContext : DbContext        {            public OrderingContext(DbContextOptions&lt;OrderingContext&gt; options) : base(options)            {                }            public DbSet&lt;Ordering.API.Models.Order&gt; Order { get; set; }        }    }  Modify Program.cs file as follows    using Microsoft.EntityFrameworkCore;    using Ordering.API.Db;        var builder = WebApplication.CreateBuilder(args);        // Add services to the container.        builder.Services.AddControllers();        builder.Services.AddDbContext&lt;OrderingContext&gt;(opt =&gt; opt.UseInMemoryDatabase(\"CatalogDB\"));        // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle    builder.Services.AddEndpointsApiExplorer();    builder.Services.AddSwaggerGen();        var app = builder.Build();        // Configure the HTTP request pipeline.    if (app.Environment.IsDevelopment())    {        app.UseSwagger();        app.UseSwaggerUI();    }        app.UseHttpsRedirection();        app.UseAuthorization();        app.MapControllers();        app.Run();  Create a conroller class name OrdersController in Ordering.API/Controllers folderOrdersController.cs    using System;    using System.Collections.Generic;    using System.Linq;    using System.Threading.Tasks;    using Microsoft.AspNetCore.Http;    using Microsoft.AspNetCore.Mvc;    using Microsoft.EntityFrameworkCore;    using Ordering.API.Db;    using Ordering.API.Models;        namespace Ordering.API.Controllers    {        [Route(\"api/[controller]\")]        [ApiController]        public class OrdersController : ControllerBase        {            private readonly OrderingContext _context;                public OrdersController(OrderingContext context)            {                _context = context;            }                // GET: api/Orders            [HttpGet(\"GetAll\")]            public async Task&lt;ActionResult&lt;IEnumerable&lt;Order&gt;&gt;&gt; GetOrder()            {                return await _context.Order.ToListAsync();            }                // GET: api/Orders/5            [HttpGet(\"{id}\")]            public async Task&lt;ActionResult&lt;Order&gt;&gt; GetOrder(int id)            {                var order = await _context.Order.FindAsync(id);                    if (order == null)                {                    return NotFound();                }                    return order;            }                // PUT: api/Orders/5            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPut(\"Edit/{id}\")]            public async Task&lt;IActionResult&gt; PutOrder(int id, Order order)            {                if (id != order.Id)                {                    return BadRequest();                }                    _context.Entry(order).State = EntityState.Modified;                    try                {                    await _context.SaveChangesAsync();                }                catch (DbUpdateConcurrencyException)                {                    if (!OrderExists(id))                    {                        return NotFound();                    }                    else                    {                        throw;                    }                }                    return NoContent();            }                // POST: api/Orders            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPost(\"Add\")]            public async Task&lt;ActionResult&lt;Order&gt;&gt; PostOrder(Order order)            {                _context.Order.Add(order);                await _context.SaveChangesAsync();                    return CreatedAtAction(\"GetOrder\", new { id = order.Id }, order);            }                // DELETE: api/Orders/5            [HttpDelete(\"Delete/{id}\")]            public async Task&lt;IActionResult&gt; DeleteOrder(int id)            {                var order = await _context.Order.FindAsync(id);                if (order == null)                {                    return NotFound();                }                    _context.Order.Remove(order);                await _context.SaveChangesAsync();                    return NoContent();            }                private bool OrderExists(int id)            {                return _context.Order.Any(e =&gt; e.Id == id);            }        }    }Step 5: Organize Location.API Project  Create CountriesController in Location.API/Controllers folder    using Microsoft.AspNetCore.Mvc;        namespace Location.API.Controllers    {        [ApiController]        [Route(\"api/[controller]\")]        public class CountriesController : ControllerBase        {          [HttpGet(\"GetAll\")]          public IEnumerable&lt;string&gt; Get()            {                return new string[] {\"Morrocco\",\"Spain\", \"Portugal\" };            }        }    }Step 6: Organize BFF.Web (API Gateway) Project  Add a configuraton file for api gateway. I keep this file name - ocelot.json. Add this file in the root directory.ocelot.json    {      //---Location Service: Start ----------//      \"Routes\": [        {          \"DownstreamPathTemplate\": \"/api/Countries/GetAll\",          \"DownstreamScheme\": \"https\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": 7003            }          ],              // Configure caching          // the cache will expire after 30 seconds.          \"FileCacheOptions\": {            \"TtlSeconds\": 30,            \"Region\": \"countriescaching\"          },              \"UpstreamPathTemplate\": \"/Countries/GetAll\",          \"UpstreamHttpMethod\": [ \"Get\" ],              // Enable case sensative Routing/URL          \"RouteIsCaseSensitive\": true        },            //---Location Service: End ----------//            // Catalog Services        //------------------//        {          \"DownstreamPathTemplate\": \"/api/Products/GetAll\",          \"DownstreamScheme\": \"https\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": 7282            }          ],              // Implement rate limiting          // maximum admitted 1 per 5s.          \"RateLimitOptions\": {            \"ClientWhitelist\": [              // This is an array used to specify the clients that should not be affected by the rate-limiting            ],            \"EnableRateLimiting\": true,            \"Period\": \"5s\",            \"PeriodTimespan\": 1,            \"Limit\": 1          },              \"UpstreamPathTemplate\": \"/Products/GetAll\",          \"UpstreamHttpMethod\": [ \"Get\" ]        },        {          \"DownstreamPathTemplate\": \"/api/Products/Add\",          \"DownstreamScheme\": \"https\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": 7282            }          ],              \"UpstreamPathTemplate\": \"/Products/Add\",          \"UpstreamHttpMethod\": [ \"Post\" ]        },            {          \"DownstreamPathTemplate\": \"/api/Products/{id}\",          \"DownstreamScheme\": \"https\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": 7282            }          ],              \"UpstreamPathTemplate\": \"/Products/{id}\",          \"UpstreamHttpMethod\": [ \"Get\" ]        },            {          \"DownstreamPathTemplate\": \"/api/Products/Edit/{id}\",          \"DownstreamScheme\": \"https\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": 7282            }          ],              \"UpstreamPathTemplate\": \"/Products/Edit/{id}\",          \"UpstreamHttpMethod\": [ \"Put\" ]        },            {          \"DownstreamPathTemplate\": \"/api/Products/Delete/{id}\",          \"DownstreamScheme\": \"https\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": 7282            }          ],              \"UpstreamPathTemplate\": \"/Products/Delete/{id}\",          \"UpstreamHttpMethod\": [ \"Delete\" ]        },            //---Catalog service : End ------------//            //---Ordering Service: Start ----------//        // Catch All Routing        {          \"DownstreamPathTemplate\": \"/{url}\",          \"DownstreamScheme\": \"https\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": 7126            }          ],              \"UpstreamPathTemplate\": \"/{url}\",          \"UpstreamHttpMethod\": [ \"Get\", \"Post\", \"Put\", \"Delete\" ]        }          ],          //---Ordering Service: End ----------//          //https://localhost:7282/api/Products/GetAll          \"GlobalConfiguration\": {        // enable request correleation id to capture request information        \"RequestIdKey\": \"X-Correlation-Id\",        \"BaseUrl\": \"https://localhost:7205/\"      }    }  Modify Program.cs file as followsProgram.cs    using Ocelot.DependencyInjection;    using Ocelot.Middleware;    using Ocelot.Cache.CacheManager;            var builder = WebApplication.CreateBuilder(args);            var environment = Environment.GetEnvironmentVariable(\"ASPNETCORE_ENVIRONMENT\");    builder.Configuration.SetBasePath(Directory.GetCurrentDirectory())        .AddJsonFile(\"ocelot.json\", optional: false, reloadOnChange: true)        .AddEnvironmentVariables();            // Add services to the container.        builder.Services.AddControllers();    // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle    builder.Services.AddEndpointsApiExplorer();        // Swagger for ocelot    //builder.Services.AddSwaggerForOcelot(builder.Configuration);    //builder.Services.AddSwaggerForOcelot();    builder.Services.AddSwaggerGen();        //For ocelot    builder.Services.AddOcelot()                // Added for caching        .AddCacheManager(x =&gt; {            x.WithDictionaryHandle();        });        var app = builder.Build();        // Configure the HTTP request pipeline.    if (app.Environment.IsDevelopment())    {        app.UseSwagger();        app.UseSwaggerUI();        //app.UseSwaggerForOcelotUI();    }        app.UseOcelot();        app.UseHttpsRedirection();        app.UseAuthorization();        app.MapControllers();        app.Run();Step 7: Run and Test application  Now run multiple (all) projects and test application using postman.  You have to check application using api gateway.  For Location service, test using https://localhost:7205/Countries/GetAll  For Catalog service, test using https://localhost:7205/Products/{endpoints}  For Ordering service, test using https://localhost:7205/api/Orders/{endpoints}Note:Configure caching in api gateway  Added the following section in ocelot.json file.    \"FileCacheOptions\": {    \"TtlSeconds\": 30,    \"Region\": \"countriescaching\"    }  Added the following code block in the the Program.cs file as follows    //For ocelotbuilder.Services.AddOcelot()            // Added for caching    .AddCacheManager(x =&gt; {        x.WithDictionaryHandle();    });      Enable case sensative URL  Add following blocks in ocelot.json for case sensative URL          // Enable case sensative Routing/URL      \"RouteIsCaseSensitive\": true      Implement rate limiting  Add following blocks in ocelot.json for rate limiting    // Implement rate limiting    // maximum admitted 1 per 5s.    \"RateLimitOptions\": {    \"ClientWhitelist\": [        // This is an array used to specify the clients that should not be affected by the rate-limiting    ],    \"EnableRateLimiting\": true,    \"Period\": \"5s\",    \"PeriodTimespan\": 1,    \"Limit\": 1    }Catch all routing  Add following blocks in ocelot.json for catch all routing    {        \"DownstreamPathTemplate\": \"/{url}\",        \"DownstreamScheme\": \"https\",        \"DownstreamHostAndPorts\": [        {            \"Host\": \"localhost\",            \"Port\": 7126        }        ],            \"UpstreamPathTemplate\": \"/{url}\",        \"UpstreamHttpMethod\": [ \"Get\", \"Post\", \"Put\", \"Delete\" ]    }Source code"
  },
  
  {
    "title": "Configure Swagger on api gateway using ocelot in asp.net core application",
    "url": "/posts/Configure-Swagger-For-Ocelot-Gateway/",
    "categories": "Microservices, Ocelot",
    "tags": "microsoft, aspnetcore, csharp, microservices, ocelot, webapi, c#, gateway, swagger",
    "date": "2023-09-24 00:00:00 +0200",
    





    
    "snippet": "IntroductionSwagger configuration on API gateway is not as simple as you are configure normal application. You have to configure it in different way. In this article I will create an API gateway us...",
    "content": "IntroductionSwagger configuration on API gateway is not as simple as you are configure normal application. You have to configure it in different way. In this article I will create an API gateway using ocelot and asp.net core application and show you how to configure swagger on API gateway.Tools and technologies used  Visual Studio 2022  .NET 6.0  In Memory Database  Entity Framework  ASP.NET Core Web API  C#  Ocelot and  MMLib.SwaggerForOcelotImplementationStep 1: Create solution and projects.  Create a solution name APIGateway  Add 4 new web api project, name - Catalog.API, Location.API, Ordering.API and BFF.Web in the solution.Here, BFF.Web project will act as API Gateway.Step 2: Install nuget packages.  Install following nuget package in Catalog.API Project    PM&gt; Install-Package Microsoft.EntityFrameworkCore.InMemoryPM&gt; Install-Package Microsoft.EntityFrameworkCore.SqlServerPM&gt; Install-Package Microsoft.EntityFrameworkCore.Tools        Install following nuget package in Ordering.API Project    PM&gt; Install-Package Microsoft.EntityFrameworkCorePM&gt; Install-Package Microsoft.EntityFrameworkCore.InMemoryPM&gt; Install-Package Microsoft.EntityFrameworkCore.SqlServerPM&gt; Install-Package Microsoft.EntityFrameworkCore.Tools        Install following nuget packages in BFF.Web Project    PM&gt; Install-Package OcelotPM&gt; Install-Package Ocelot.Provider.PollyPM&gt; Install-Package Ocelot.Cache.CacheManagerPM&gt; Install-Package MMLib.SwaggerForOcelot      Step 3: Organize Catalog.API Project  Create a Product model class in Catalog.API/Model folderProduct.cs    using System.ComponentModel.DataAnnotations;    using System.ComponentModel.DataAnnotations.Schema;        namespace Catalog.API.Model    {        public class Product        {            [Key]            [DatabaseGenerated(DatabaseGeneratedOption.Identity)]            public int Id { get; set; }            public string Name { get; set; }                public string Description { get; set; }                public decimal Price { get; set; }                public int AvailableStock { get; set; }                public int RestockThreshold { get; set; }        }    }  Create a CatalogContext class in Catalog.API/Db folderCatalogContext.cs    using Catalog.API.Model;    using Microsoft.EntityFrameworkCore;        namespace Catalog.API.Db    {        public class CatalogContext : DbContext        {            public CatalogContext(DbContextOptions&lt;CatalogContext&gt; options) : base(options)            {                }                protected override void OnModelCreating(ModelBuilder modelBuilder)            {                }                protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)            {                base.OnConfiguring(optionsBuilder);            }                public DbSet&lt;Product&gt; Products { get; set; }        }    }  Modify Program.cs file as follows    using Catalog.API.Db;    using Microsoft.EntityFrameworkCore;        var builder = WebApplication.CreateBuilder(args);        // Add services to the container.        builder.Services.AddControllers();        builder.Services.AddDbContext&lt;CatalogContext&gt;(opt =&gt; opt.UseInMemoryDatabase(\"CatalogDB\"));        // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle    builder.Services.AddEndpointsApiExplorer();    builder.Services.AddSwaggerGen();        var app = builder.Build();        // Configure the HTTP request pipeline.    if (app.Environment.IsDevelopment())    {        app.UseSwagger();        app.UseSwaggerUI();    }        app.UseHttpsRedirection();        app.UseAuthorization();        app.MapControllers();        app.Run();  Create a conroller class name ProductsController in Catalog.API/Controllers folderCatalogController.cs    using System;    using System.Collections.Generic;    using System.Linq;    using System.Threading.Tasks;    using Microsoft.AspNetCore.Http;    using Microsoft.AspNetCore.Mvc;    using Microsoft.EntityFrameworkCore;    using Catalog.API.Db;    using Catalog.API.Model;        namespace Catalog.API.Controllers    {        [Route(\"api/[controller]\")]        [ApiController]        public class ProductsController : ControllerBase        {            private readonly CatalogContext _context;                public ProductsController(CatalogContext context)            {                _context = context;            }                // GET: api/Products            [HttpGet(\"GetAll\")]            public async Task&lt;ActionResult&lt;IEnumerable&lt;Product&gt;&gt;&gt; GetProducts()            {                return await _context.Products.ToListAsync();            }                // GET: api/Products/5            [HttpGet(\"{id}\")]            public async Task&lt;ActionResult&lt;Product&gt;&gt; GetProduct(int id)            {                var product = await _context.Products.FindAsync(id);                    if (product == null)                {                    return NotFound();                }                    return product;            }                // PUT: api/Products/5            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPut(\"Edit/{id}\")]            public async Task&lt;IActionResult&gt; PutProduct(int id, Product product)            {                if (id != product.Id)                {                    return BadRequest();                }                    _context.Entry(product).State = EntityState.Modified;                    try                {                    await _context.SaveChangesAsync();                }                catch (DbUpdateConcurrencyException)                {                    if (!ProductExists(id))                    {                        return NotFound();                    }                    else                    {                        throw;                    }                }                    return NoContent();            }                // POST: api/Products            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPost(\"Add\")]            public async Task&lt;ActionResult&lt;Product&gt;&gt; PostProduct(Product product)            {                _context.Products.Add(product);                await _context.SaveChangesAsync();                    return CreatedAtAction(\"GetProduct\", new { id = product.Id }, product);            }                // DELETE: api/Products/5            [HttpDelete(\"Delete/{id}\")]            public async Task&lt;IActionResult&gt; DeleteProduct(int id)            {                var product = await _context.Products.FindAsync(id);                if (product == null)                {                    return NotFound();                }                    _context.Products.Remove(product);                await _context.SaveChangesAsync();                    return NoContent();            }                private bool ProductExists(int id)            {                return _context.Products.Any(e =&gt; e.Id == id);            }        }    }Step 4: Organize Ordering.API Project  Create a Order model class in Ordering.API/Model folderOrder.cs    namespace Ordering.API.Models    {        public class Order        {            public int Id { get; set; }            public string Address { get; set; }                public DateTime OrderDate { get; set; }                public string Comments { get; set; }        }    }  Create a OrderingContext class in Ordering.API/Db folderOrderingContext.cs    using Microsoft.EntityFrameworkCore;    using Ordering.API.Models;        namespace Ordering.API.Db    {        public class OrderingContext : DbContext        {            public OrderingContext(DbContextOptions&lt;OrderingContext&gt; options) : base(options)            {                }            public DbSet&lt;Ordering.API.Models.Order&gt; Order { get; set; }        }    }  Modify Program.cs file as follows    using Microsoft.EntityFrameworkCore;    using Ordering.API.Db;        var builder = WebApplication.CreateBuilder(args);        // Add services to the container.        builder.Services.AddControllers();        builder.Services.AddDbContext&lt;OrderingContext&gt;(opt =&gt; opt.UseInMemoryDatabase(\"CatalogDB\"));        // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle    builder.Services.AddEndpointsApiExplorer();    builder.Services.AddSwaggerGen();        var app = builder.Build();        // Configure the HTTP request pipeline.    if (app.Environment.IsDevelopment())    {        app.UseSwagger();        app.UseSwaggerUI();    }        app.UseHttpsRedirection();        app.UseAuthorization();        app.MapControllers();        app.Run();      Create a conroller class name OrdersController in Ordering.API/Controllers folderOrdersController.cs    using System;    using System.Collections.Generic;    using System.Linq;    using System.Threading.Tasks;    using Microsoft.AspNetCore.Http;    using Microsoft.AspNetCore.Mvc;    using Microsoft.EntityFrameworkCore;    using Ordering.API.Db;    using Ordering.API.Models;        namespace Ordering.API.Controllers    {        [Route(\"api/[controller]\")]        [ApiController]        public class OrdersController : ControllerBase        {            private readonly OrderingContext _context;                public OrdersController(OrderingContext context)            {                _context = context;            }                // GET: api/Orders            [HttpGet(\"GetAll\")]            public async Task&lt;ActionResult&lt;IEnumerable&lt;Order&gt;&gt;&gt; GetOrder()            {                return await _context.Order.ToListAsync();            }                // GET: api/Orders/5            [HttpGet(\"{id}\")]            public async Task&lt;ActionResult&lt;Order&gt;&gt; GetOrder(int id)            {                var order = await _context.Order.FindAsync(id);                    if (order == null)                {                    return NotFound();                }                    return order;            }                // PUT: api/Orders/5            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPut(\"Edit/{id}\")]            public async Task&lt;IActionResult&gt; PutOrder(int id, Order order)            {                if (id != order.Id)                {                    return BadRequest();                }                    _context.Entry(order).State = EntityState.Modified;                    try                {                    await _context.SaveChangesAsync();                }                catch (DbUpdateConcurrencyException)                {                    if (!OrderExists(id))                    {                        return NotFound();                    }                    else                    {                        throw;                    }                }                    return NoContent();            }                // POST: api/Orders            // To protect from overposting attacks, see https://go.microsoft.com/fwlink/?linkid=2123754            [HttpPost(\"Add\")]            public async Task&lt;ActionResult&lt;Order&gt;&gt; PostOrder(Order order)            {                _context.Order.Add(order);                await _context.SaveChangesAsync();                    return CreatedAtAction(\"GetOrder\", new { id = order.Id }, order);            }                // DELETE: api/Orders/5            [HttpDelete(\"Delete/{id}\")]            public async Task&lt;IActionResult&gt; DeleteOrder(int id)            {                var order = await _context.Order.FindAsync(id);                if (order == null)                {                    return NotFound();                }                    _context.Order.Remove(order);                await _context.SaveChangesAsync();                    return NoContent();            }                private bool OrderExists(int id)            {                return _context.Order.Any(e =&gt; e.Id == id);            }        }    }Step 5: Organize Location.API Project  Create CountriesController in Location.API/Controllers folder    using Microsoft.AspNetCore.Mvc;        namespace Location.API.Controllers    {        [ApiController]        [Route(\"api/[controller]\")]        public class CountriesController : ControllerBase        {          [HttpGet(\"GetAll\")]          public IEnumerable&lt;string&gt; Get()            {                return new string[] {\"America\",\"Bangladesh\", \"Canada\" };            }        }    }Step 6: Organize BFF.Web (API Gateway) Project  Create a folder name Routes and add the following files in that folderocelot.catalog.api.json    {      \"Routes\": [        {          \"DownstreamPathTemplate\": \"/{everything}\",          \"DownstreamScheme\": \"https\",          \"SwaggerKey\": \"catalog\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": \"7282\"            }          ],          \"UpstreamPathTemplate\": \"/catalog/{everything}\",          \"UpstreamHttpMethod\": [            \"GET\",            \"POST\",            \"PUT\",            \"DELETE\"          ]        }      ]    }ocelot.location.api.json    {      \"Routes\": [        {          \"DownstreamPathTemplate\": \"/{everything}\",          \"DownstreamScheme\": \"https\",          \"SwaggerKey\": \"location\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": \"7003\"            }          ],          \"UpstreamPathTemplate\": \"/location/{everything}\",          \"UpstreamHttpMethod\": [            \"GET\",            \"POST\",            \"PUT\",            \"DELETE\"          ]        }      ]    }ocelot.ordering.api.json    {      \"Routes\": [        {          \"DownstreamPathTemplate\": \"/{everything}\",          \"DownstreamScheme\": \"https\",          \"SwaggerKey\": \"ordering\",          \"DownstreamHostAndPorts\": [            {              \"Host\": \"localhost\",              \"Port\": \"7126\"            }          ],          \"UpstreamPathTemplate\": \"/ordering/{everything}\",          \"UpstreamHttpMethod\": [            \"GET\",            \"POST\",            \"PUT\",            \"DELETE\"          ]        }      ]    }ocelot.global.json    {      \"GlobalConfiguration\": {        \"BaseUrl\": \"http://localhost:5205\"      }    }ocelot.SwaggerEndPoints.json    {      \"SwaggerEndPoints\": [        {          \"Key\": \"bffweb\",          \"TransformByOcelotConfig\": false,          \"Config\": [            {              \"Name\": \"BFF.Web\",              \"Version\": \"1.0\",              \"Url\": \"http://localhost:5205/swagger/v1/swagger.json\"            }          ]        },        {          \"Key\": \"location\",          \"TransformByOcelotConfig\": true,          \"Config\": [            {              \"Name\": \"Location.API\",              \"Version\": \"1.0\",              \"Url\": \"http://localhost:5205/location/swagger/v1/swagger.json\"            }          ]        },        {          \"Key\": \"catalog\",          \"TransformByOcelotConfig\": true,          \"Config\": [            {              \"Name\": \"Catalog.API\",              \"Version\": \"1.0\",              \"Url\": \"http://localhost:5205/catalog/swagger/v1/swagger.json\"            }          ]        },        {          \"Key\": \"ordering\",          \"TransformByOcelotConfig\": true,          \"Config\": [            {              \"Name\": \"Ordering.API\",              \"Version\": \"1.0\",              \"Url\": \"http://localhost:5205/catalog/swagger/v1/swagger.json\"            }          ]        }      ]    }  Add AlterUpstream Class in Config FolderAlterUpstream.cs    using Newtonsoft.Json;    using Newtonsoft.Json.Linq;        namespace BFF.Web.Config    {        public class AlterUpstream        {            public static string AlterUpstreamSwaggerJson(HttpContext context, string swaggerJson)            {                var swagger = JObject.Parse(swaggerJson);                // ... alter upstream json                return swagger.ToString(Formatting.Indented);            }        }    }  Modify Program.cs file as followsProgram.cs    using BFF.Web.Config;    using MMLib.SwaggerForOcelot.DependencyInjection;    using Ocelot.DependencyInjection;    using Ocelot.Middleware;    using Ocelot.Provider.Polly;        var builder = WebApplication.CreateBuilder(args);        var routes = \"Routes\";        builder.Configuration.AddOcelotWithSwaggerSupport(options =&gt;    {        options.Folder = routes;    });        builder.Services.AddOcelot(builder.Configuration).AddPolly();    builder.Services.AddSwaggerForOcelot(builder.Configuration);        var environment = Environment.GetEnvironmentVariable(\"ASPNETCORE_ENVIRONMENT\");    builder.Configuration.SetBasePath(Directory.GetCurrentDirectory())        .AddOcelot(routes, builder.Environment)        .AddEnvironmentVariables();            // Add services to the container.        builder.Services.AddControllers();    // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle    builder.Services.AddEndpointsApiExplorer();        // Swagger for ocelot    builder.Services.AddSwaggerGen();        var app = builder.Build();        // Configure the HTTP request pipeline.    if (app.Environment.IsDevelopment())    {        app.UseSwagger();    }            app.UseHttpsRedirection();        app.UseAuthorization();        app.UseSwaggerForOcelotUI(options =&gt;    {        options.PathToSwaggerGenerator = \"/swagger/docs\";        options.ReConfigureUpstreamSwaggerJson = AlterUpstream.AlterUpstreamSwaggerJson;        }).UseOcelot().Wait();        app.MapControllers();        app.Run();Step 7: Run and Test application  Now run multiple (all) projects and test application using postman.  Check all end point using api gateway and swagger using the following URLhttps://localhost:7205/swagger/index.html  Select Swagger definition from top right corner of BFFSource code"
  },
  
  {
    "title": "C# | TDD Example using xUnit and Moq",
    "url": "/posts/C-TDD-Example-using-xUnit-and-Moq/",
    "categories": "TDD, C#",
    "tags": "microsoft, csharp, c#, tdd, unittest",
    "date": "2023-09-07 00:00:00 +0200",
    





    
    "snippet": "In Test-Driven Development (TDD), we write tests before writing the actual code. This example demonstrates how to create unit tests in C# using xUnit, how to use the Moq framework for mocking, and ...",
    "content": "In Test-Driven Development (TDD), we write tests before writing the actual code. This example demonstrates how to create unit tests in C# using xUnit, how to use the Moq framework for mocking, and how to refactor tests using Fact and Theory attributes.PrerequisitesBefore we start, make sure you have the following installed:  Visual Studio or Visual Studio Code (or any C# IDE of your choice)  xUnit.net testing framework  Moq mocking frameworkScenarioSuppose we are building a simple library that calculates the total price of items in a shopping cart.Step 1: Set Up the ProjectCreate a new C# project and add references to the xUnit and Moq libraries.Step 2: Write the Initial TestLet‚Äôs start by writing a test for our shopping cart. Create a test class, and write a Fact that checks if the cart‚Äôs total price is calculated correctly:using System;using Xunit;public class ShoppingCartTests{    [Fact]    public void CalculateTotalPrice_CartWithItems_ReturnsTotalPrice()    {        // Arrange        var cart = new ShoppingCart();        cart.AddItem(new Item(\"Item 1\", 10.0));        cart.AddItem(new Item(\"Item 2\", 15.0));        // Act        var totalPrice = cart.CalculateTotalPrice();        // Assert        Assert.Equal(25.0, totalPrice);    }}Step 3: Write the Initial CodeNow, create the ShoppingCart class and implement the CalculateTotalPrice method:public class ShoppingCart{    private List&lt;Item&gt; items = new List&lt;Item&gt;();    public void AddItem(Item item)    {        items.Add(item);    }    public double CalculateTotalPrice()    {        return items.Sum(item =&gt; item.Price);    }}Step 4: Mocking with MoqSuppose our ShoppingCart class depends on an external data source (e.g., a database). To test it, we can use Moq to mock this dependency. Create an interface for the data source, implement it, and inject it into the ShoppingCart:public interface IDataSource{    List&lt;Item&gt; GetItems();}public class Database : IDataSource{    public List&lt;Item&gt; GetItems()    {        // Simulate database call        return new List&lt;Item&gt;        {            new Item(\"Item 1\", 10.0),            new Item(\"Item 2\", 15.0)        };    }}public class ShoppingCart{    private IDataSource dataSource;    public ShoppingCart(IDataSource dataSource)    {        this.dataSource = dataSource;    }    // ...}Step 5: Refactor the Test with TheoryInstead of Fact, let‚Äôs refactor the test using Theory. This allows us to use data from multiple test cases. For instance, we can test the CalculateTotalPrice method with different sets of items:[Theory][InlineData(new[] { 10.0, 15.0 }, 25.0)][InlineData(new[] { 5.0, 7.0, 8.0 }, 20.0)]public void CalculateTotalPrice_CartWithItems_ReturnsTotalPrice(double[] itemPrices, double expectedTotalPrice){    // Arrange    var cart = new ShoppingCart(CreateMockDataSource(itemPrices));    // Act    var totalPrice = cart.CalculateTotalPrice();    // Assert    Assert.Equal(expectedTotalPrice, totalPrice);}Here, we‚Äôre using Theory to run the test with different sets of item prices. The CreateMockDataSource function sets up a Moq mock of the IDataSource interface.What Next?  This example demonstrates how to use TDD with xUnit, Moq for mocking, and how to refactor tests using Fact and Theory attributes. By following TDD, you can ensure that your code is thoroughly tested and that it meets the specified requirements."
  },
  
  {
    "title": "Create .Net custom template using GitHub Packages Registry",
    "url": "/posts/Create-.Net-custom-template-using-GitHub-Packages-Registry/",
    "categories": "NugetPackage, GitHub",
    "tags": "microsoft, csharp, c#, github, nugetpackage, aspnetcore",
    "date": "2023-08-21 00:00:00 +0200",
    





    
    "snippet": "Introduction.NET gives us opportunity to create custom template for future use and GitHub packages registry is most popular now a days to host custom template. In this article, I will show you how ...",
    "content": "Introduction.NET gives us opportunity to create custom template for future use and GitHub packages registry is most popular now a days to host custom template. In this article, I will show you how to create .net custom template using GitHub packages registry.Tools and Technology uses  Visual Studio 2022  .NET 6  C#  GitHubImplementationStep 1: Create a personal access token (PAT) from GitHub  Login into you GitHub  Go to settings -&gt; Developer Settings -&gt; Personal Access Tokens  Click ‚ÄúGenerate new token‚Äù button  Type Note for the token, expiration days      Select scope for the token ‚Äì here I have selected repo, write:packages, delete:packages as shown below.        Now click ‚ÄúGenerate Token‚Äù at the bottom of the panel      Copy the token and store the token for further use because you cannot find it later      Step 2: Add Nuget Source in visual studio  Type the following command to add sourcedotnet nuget add source https://nuget.pkg.github.com/hbolajraf/index.json --name github-hbolajraf --username hbolajraf --password &lt;Your personal Access Token&gt;      You will see a source is added in C:\\Users\\hbolajraf\\AppData\\Roaming\\NuGet\\NuGet.Config file    You can add source from visual studio Tools -&gt; Options -&gt; NuGet Package Manager -&gt; Package Sources  Restart visual studio to get new nuget package sourceStep 3: Create template for your application  Create a project or multiple projects using a solution file.  Here, I have created a clean architecture template with a solution file and multiple projects      Create a folder name ‚Äì ‚Äú.template.config‚Äù in the root directory of your application.        Create a file template.json in .template.config folder.  Add the following content to template.json filetemplate.json    {      \"$schema\": \"http://json.schemastore.org/template\",      \"author\": \"hbolajraf Hasan\",      \"classifications\": [        \"dotnet\",        \"CleanArchitecture\"      ],      \"name\": \"Clean Architecture project template\",      \"description\": \"Project template to create project using Clean Architecture\",      \"identity\": \"CleanArchitecture\",      \"shortName\": \"CleanArchitecture\",      \"sourceName\": \"CleanArch\",      \"tags\": {        \"language\": \"C#\",        \"type\": \"project\"      },      \"symbols\": {        \"Framework\": {          \"type\": \"parameter\",          \"description\": \"The target framework for the project.\",          \"datatype\": \"choice\",          \"choices\": [            {              \"choice\": \"net6.0\"            },            {              \"choice\": \"net5.0\"          }          ],          \"defaultValue\": \"net6.0\",          \"replaces\": \"{TargetFramework}\"        }      }    }Step 4: Install and create template locally (Optional)  Go to one where ‚Äú.template.config‚Äù folder exists.  Now run the following command. Don‚Äôt forgot to add space ‚Äú.‚Äù at the end.dotnet new --install .  You will see in the output that template is created. You will see Short Name of template which is used to install template.  Now go to the directory where you want to install template and type the following command.dotnet new CleanArchitecture    #or,dotnet new CleanArchitecture --forceHere CleanArchitecture is short name of the template  To create template by another name type as follows.dotnet new CleanArchitecture -o LocationNow projects name will be Location instead of CleanArch as mentioned in the previous json file.  Now go to the same directory to uninstall the template and type the following command.dotnet new --uninstall .```console    ## Step 5: Packing a template into a NuGet Package (nupkg file)*   Create a .csproj file one directory up of ‚Äú.template.config‚Äù folder.*   In my case the folder structure as follows        ![](/posts/2022/temp-04.PNG)    **Add the following content in TemplatePack.csproj project.****TemplatePack.csproj**```xml         &lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt;           &lt;PropertyGroup&gt;             &lt;PackageType&gt;Template&lt;/PackageType&gt;             &lt;PackageVersion&gt;1.0.0&lt;/PackageVersion&gt;             &lt;PackageId&gt;hbolajraf.CleanArchitecture.Templates&lt;/PackageId&gt;             &lt;Title&gt;Clean Architecture Template&lt;/Title&gt;             &lt;Authors&gt;hbolajraf Hasan&lt;/Authors&gt;             &lt;Description&gt;Clean Architecture Template&lt;/Description&gt;             &lt;PackageTags&gt;dotnet-new;templates;clean-architecture&lt;/PackageTags&gt;            &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;             &lt;IncludeContentInPack&gt;true&lt;/IncludeContentInPack&gt;             &lt;IncludeBuildOutput&gt;false&lt;/IncludeBuildOutput&gt;             &lt;ContentTargetFolders&gt;content&lt;/ContentTargetFolders&gt;             &lt;NoWarn&gt;$(NoWarn);NU5128&lt;/NoWarn&gt;             &lt;NoDefaultExcludes&gt;true&lt;/NoDefaultExcludes&gt;         &lt;RepositoryUrl&gt;https://github.com/hbolajraf/public-packages&lt;/RepositoryUrl&gt;          &lt;/PropertyGroup&gt;           &lt;ItemGroup&gt;         &lt;Content Include=\"CleanArchitecture\\**\\*\" Exclude=\"CleanArchitecture\\**\\bin\\**;CleanArchitecture\\**\\obj\\**\" /&gt;         &lt;Compile Remove=\"..\\**\\*\" /&gt;           &lt;/ItemGroup&gt;       &lt;/Project&gt;   To create package go to the directory where TemplatePack.csproj file exists and type the following command.dotnet pack  You will hbolajraf.CleanArchitecture.Templates.1.0.0.nupkg file is created in bin/Debug folder.Step 6: Now push the package to github package registry  Go to the directory where hbolajraf.CleanArchitecture.Templates.1.0.0.nupkg is exists.      Type the following command to push the package in github package registry    dotnet nuget push .\\hbolajraf.CleanArchitecture.Templates.1.0.0.nupkg ‚Äìapi-key  --source github-hbolajraf    Here, ‚Äúgithub-hbolajraf‚Äù is a github source which we have added in step ‚Äì 2.  Now login your github and you will see a template is uploaded to your package registry.Step 7: Download template and install in local machine  Run the following command to install in local machinedotnet new --install  hbolajraf.CleanArchitecture.Templateshbolajraf.CleanArchitecture.Templates is package Id.output:The following template packages will be installed:   hbolajraf.CleanArchitecture.TemplatesSuccess: hbolajraf.CleanArchitecture.Templates::1.0.0 installed the following templates:Template Name                        Short Name         Language  Tags-----------------------------------  -----------------  --------  ------------------------Clean Architecture project template  CleanArchitecture  [C#]      dotnet/CleanArchitecture  Now go to the directory where you want to regenerate the template and type the following command.dotnet new CleanArchitectureHere CleanArchitecture is the short name of the templateNote  To see installed template in locally use the following command. You will also see how to uninstall the particular template.dotnet new --uninstall  To uninstall a particular template from local machine, use the following command.dotnet new --uninstall hbolajraf.CleanArchitecture.Templatesdotnet new ‚Äìuninstall &lt;package id&gt; Source code"
  },
  
  {
    "title": "Deploy .net core NuGet Packages in GitHub Packages Registry",
    "url": "/posts/Deploy-.net-core-NuGet-Packages-in-GitHub-Packages-Registry/",
    "categories": "NugetPackage, GitHub",
    "tags": "microsoft, csharp, c#, nuget, nugetpackage, aspnetcore, github",
    "date": "2023-08-19 00:00:00 +0200",
    





    
    "snippet": "IntroductionGitHub packages registries is most popular now a days. It offers different packages registries for most used package managers, such as NuGet, npm, Docker etc. In this article, I will sh...",
    "content": "IntroductionGitHub packages registries is most popular now a days. It offers different packages registries for most used package managers, such as NuGet, npm, Docker etc. In this article, I will show you how to host a .net core NuGet Package in GitHub Packages Registry.Tools and Technology uses  Visual Studio 2022  .NET 6  C#  GitHubImplementationStep 1: Create a personal access token (PAT) from GitHub  Login into you GitHub  Go to settings -&gt; Developer Settings -&gt; Personal Access Tokens  Click ‚ÄúGenerate new token‚Äù button  Type Note for the token, expiration days      Select scope for the token ‚Äì here I have selected repo, write:packages, delete:packages as shown below.        Now click ‚ÄúGenerate Toke‚Äù at the bottom of the panel      Copy the token and store the token for further use because you cannot find it later      Step 2: Add Nuget Source in visual studio  Type the following command to add sourcedotnet nuget add source https://nuget.pkg.github.com/hbolajraf/index.json --name github-hbolajraf --username hbolajraf --password &lt;Your personal Access Token&gt;      You will see a source is added in C:\\Users\\hbolajraf\\AppData\\Roaming\\NuGet\\NuGet.Config file    Optional: You can also add source from visual studio Tools -&gt; Options -&gt; NuGet Package Manager -&gt; Package Sources  Restart visual studio to get new nuget package sourceStep 3: Create a class library to publish in GitHub Packages  Create a class library name ‚Äì ‚ÄòCryptoEngine‚Äù  Create a class CryptoGenerator as follows    using System.Security.Cryptography;    using System.Text;        namespace CryptoEngine    {        public class CryptoGenerator        {            public static string GenerateSha256Hash(string plainText)            {                // Create a SHA256                   using (SHA256 sha256Hash = SHA256.Create())                {                    // ComputeHash - returns byte array                      byte[] bytes = sha256Hash.ComputeHash(Encoding.UTF8.GetBytes(plainText));                        // Convert byte array to a string                       StringBuilder builder = new StringBuilder();                    for (int i = 0; i &lt; bytes.Length; i++)                    {                        builder.Append(bytes[i].ToString(\"x2\"));                    }                    return builder.ToString();                }            }        }    }  Click right button on class library project -&gt; Package -&gt; General  Mark ‚ÄúProduce a package file during build operations‚Äù  Type Package ID, Package Version, Authors, Company, Product, Description  Type repository URL ‚Äì A github repository and save  Now you will see the csproj file as followsCryptoEngine.csproj    &lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt;          &lt;PropertyGroup&gt;        &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt;        &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;        &lt;Nullable&gt;enable&lt;/Nullable&gt;        &lt;GeneratePackageOnBuild&gt;True&lt;/GeneratePackageOnBuild&gt;        &lt;PackageId&gt;hbolajraf.CryptoEngine&lt;/PackageId&gt;        &lt;Version&gt;1.0.0&lt;/Version&gt;        &lt;Authors&gt;hbolajraf hasan&lt;/Authors&gt;        &lt;Company&gt;hbolajraf.NET&lt;/Company&gt;        &lt;Product&gt;CryptoEngine&lt;/Product&gt;        &lt;Description&gt;Chipper text generator&lt;/Description&gt;        &lt;RepositoryUrl&gt;https://github.com/hbolajraf/public-packages&lt;/RepositoryUrl&gt;      &lt;/PropertyGroup&gt;        &lt;/Project&gt;Step 4: Create a NuGet Package  Click right button on project and select Pack  A NuGet package will be generated in bin/Debug folder ‚Äì In this case the nuget package name is hbolajraf.CryptoEngine.1.0.0.nupkg  Or, Go to the directory where .csproj file exists and right the following command to generate nuget packagedotnet packStep 5: Push NuGet package to GitHub Package Registry  Go to the directory where package generated ‚Äì bin/Debug in this case.  Type following commanddotnet nuget push .\\hbolajraf.CryptoEngine.1.0.0.nupkg --api-key &lt;your github access token&gt; --source github-hbolajrafHere github-hbolajraf is my nuget source name for visual studio. Already added in step 2.  Now login to your Github account and go to Packages tab, you will see a package is uploaded. In this case package name is hbolajraf.CryptoEngineStep 6: Use already uploaded package in a project  If Nuget package source is not added, add it using step ‚Äì 2  Go to package manager console  Select Package Source as ‚Äúgithub-hbolajraf‚Äù and type following commandPM&gt; Install-Package hbolajraf.CryptoEngine  Or right button on project -&gt; Manage Nuget Packages  Select Package source ‚Äúgithub-hbolajraf‚Äù  Browse and install package hbolajraf.CryptoEngineSource code"
  },
  
  {
    "title": "Create Nuget Package using .NET Standard",
    "url": "/posts/Create-Nuget-Package-using-.NET-Standard/",
    "categories": "NugetPackage, C#",
    "tags": "microsoft, csharp, c#, nuget, nugetpackage",
    "date": "2023-08-17 00:00:00 +0200",
    





    
    "snippet": "Tools and technologies used  Visual Studio 2022  .NET Standard 2.1  Nuget.exeImplementationNew Project CreationUnder Visual Studio create a new Project Class Library and use .NET Standard 2.1 as ta...",
    "content": "Tools and technologies used  Visual Studio 2022  .NET Standard 2.1  Nuget.exeImplementationNew Project CreationUnder Visual Studio create a new Project Class Library and use .NET Standard 2.1 as target framework due to compatibility reason with latests versions of .NET CORE Frameworks.Use Nuget CLI to generate files1.Download Nuget.exe fileUse the following link to download the latests version of Nuget.exe file.2.Generate nuspec file Under the new project folder created befor, open a cmd console and run the comand bellow in order to generate the nuspec file.nuget spec NewProjectName.csprojThe result of the command should generate a new file which has the content below :&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;package &gt;  &lt;metadata&gt;    &lt;id&gt;$id$&lt;/id&gt;    &lt;version&gt;$version$&lt;/version&gt;    &lt;title&gt;$title$&lt;/title&gt;    &lt;authors&gt;$author$&lt;/authors&gt;    &lt;requireLicenseAcceptance&gt;false&lt;/requireLicenseAcceptance&gt;    &lt;license type=\"expression\"&gt;MIT&lt;/license&gt;    &lt;!-- &lt;icon&gt;icon.png&lt;/icon&gt; --&gt;    &lt;projectUrl&gt;http://project_url_here_or_delete_this_line/&lt;/projectUrl&gt;    &lt;description&gt;$description$&lt;/description&gt;    &lt;releaseNotes&gt;Summary of changes made in this release of the package.&lt;/releaseNotes&gt;    &lt;copyright&gt;$copyright$&lt;/copyright&gt;    &lt;tags&gt;Tag1 Tag2&lt;/tags&gt;  &lt;/metadata&gt;&lt;/package&gt;3.Generate nupkg fileYou have two solutions order to generate the nuget package file(nupkg)using the post-build event of the project  Under Visual Studio right click on the NewProjectName.crproj and select post-build event tab.After that put the command bellow and Build the solutionnuget pack \"$(ProjectPath)\" -Symbols -Properties Configuration=$(ConfigurationName) -IncludeReferencedProjects -OutputDirectory \"C:\\Dev\\nuget_packages\\NewProjectName\\\"using the Nuget CLI command  Under the cmd window tape the command bellow in order to generate the nuget packagenuget pack MyProject.csproj -properties Configuration=Release -OutputDirectory \"C:\\Dev\\nuget_packages\\NewProjectName\\\"In all cases the new nuget package file will be generated under the output directory : *C:\\Dev\\nuget_packages\\NewProjectName*What next ?Once you‚Äôve created a package, which is a .nupkg file, you can publish it to the gallery of your choice(Artifactory, Azure artifacts or GitHub Package registry)"
  },
  
  {
    "title": "C# | ASP.NET Web APIs with Zipkin",
    "url": "/posts/ASP.NET-Web-APIs-with-Zipkin-and-C/",
    "categories": "Web API, C#",
    "tags": "microsoft, csharp, c#, webapi, zipkin",
    "date": "2023-08-09 00:00:00 +0200",
    





    
    "snippet": "ASP.NET Web APIs with Zipkin and C#Zipkin is a distributed tracing system that helps you monitor and troubleshoot microservices-based applications. This guide will walk you through the steps to int...",
    "content": "ASP.NET Web APIs with Zipkin and C#Zipkin is a distributed tracing system that helps you monitor and troubleshoot microservices-based applications. This guide will walk you through the steps to integrate Zipkin with a C# Web API.PrerequisitesBefore you start, make sure you have the following prerequisites:  .NET Core SDK installed on your system.  A C# Web API project that you want to instrument with Zipkin.  Zipkin server up and running (you can deploy Zipkin using Docker or as a standalone service).Steps to Integrate ZipkinStep 1: Install the Required PackagesYou need to install the necessary packages to enable Zipkin integration in your C# Web API project. Open your project in the terminal or command prompt and use the following command to install the required NuGet packages:dotnet add package OpenTracingdotnet add package OpenTracing.Contrib.NetCoredotnet add package JaegerStep 2: Configure Zipkin TracingIn your C# Web API project, you‚Äôll need to configure Zipkin tracing. Create a configuration class or use your existing configuration:using Jaeger;using Jaeger.Reporters;using Jaeger.Samplers;using Jaeger.Senders;using OpenTracing;public static class ZipkinConfig{    public static ITracer ConfigureTracer(string serviceName)    {        var reporter = new RemoteReporter.Builder()            .WithSender(new UdpSender(\"your-zipkin-server-host\", 9411, 0))            .Build();        var sampler = new ConstSampler(true);        var tracer = new Tracer.Builder(serviceName)            .WithReporter(reporter)            .WithSampler(sampler)            .Build();        GlobalTracer.Register(tracer);        return tracer;    }}Step 3: Instrument Your Web APIIn your Web API controllers or middleware, you can use the ITracer to start and finish spans, which represent different parts of your API request:using System;using Microsoft.AspNetCore.Mvc;using OpenTracing;[Route(\"api/[controller]\")]public class MyController : ControllerBase{    private readonly ITracer _tracer;    public MyController(ITracer tracer)    {        _tracer = tracer;    }    [HttpGet]    public ActionResult&lt;string&gt; Get()    {        using (var scope = _tracer.BuildSpan(\"MyController.Get\").StartActive())        {            // Your API logic here            return \"Hello, World!\";        }    }}Step 4: Start Zipkin and Observe TracesStart your Zipkin server, and your C# Web API is now instrumented with Zipkin tracing. When you make requests to your API, you can use the Zipkin web UI to observe traces and troubleshoot issues in your microservices-based application.What Next?  That‚Äôs it! You‚Äôve successfully integrated Zipkin with your C# Web API to monitor and trace requests across your microservices."
  },
  
  {
    "title": "Working with SonarLint and SonarQube in Visual Studio",
    "url": "/posts/Working-with-SonarLint-and-SonarQube-in-Visual-Studio/",
    "categories": "Tips And Tricks, Visual Studio",
    "tags": "microsoft, visualstudio, sonarqube, sonarlint",
    "date": "2023-08-05 00:00:00 +0200",
    





    
    "snippet": "Working with SonarLint and SonarQube in Visual StudioSonarLint and SonarQube are powerful tools for code quality and static code analysis in C# and other programming languages. They help you identi...",
    "content": "Working with SonarLint and SonarQube in Visual StudioSonarLint and SonarQube are powerful tools for code quality and static code analysis in C# and other programming languages. They help you identify and fix code issues and vulnerabilities. In this guide, we‚Äôll walk you through how to set up and use SonarLint in Visual Studio and integrate it with SonarQube for more advanced analysis.Prerequisites      Visual Studio: Make sure you have Visual Studio installed on your machine. SonarLint works as a Visual Studio extension.        SonarQube Server: If you plan to use SonarQube for more advanced analysis, you‚Äôll need access to a SonarQube server. You can install one locally or use a remote server.  Setting Up SonarLint1. Install SonarLint Extension:  Open Visual Studio.  Go to Extensions -&gt; Manage Extensions.  Search for ‚ÄúSonarLint‚Äù and install the extension.2. Binding to a SonarQube Server (Optional):  If you want to connect SonarLint to your SonarQube server for synchronized rules and quality profiles, go to Tools -&gt; Options -&gt; SonarLint.  Click ‚ÄúConnect to SonarQube‚Äù and provide the server URL and authentication details.3. Binding to SonarQube Projects (Optional):  If connected to a SonarQube server, you can bind your Visual Studio projects to SonarQube projects. This ensures that your code is analyzed using SonarQube rules.  Right-click on the project in Solution Explorer -&gt; SonarLint -&gt; Bind to SonarQube project.4. Analyzing Code:  SonarLint will automatically analyze your code in real-time as you work in Visual Studio.  Detected issues and suggestions will be highlighted in your code, and you can see details in the SonarLint window.Setting Up SonarQube IntegrationTo perform more advanced analysis and manage projects centrally, you can integrate SonarQube with Visual Studio.1. Install SonarQube Scanner for MSBuild:  Download and install the SonarQube Scanner for MSBuild.2. Configure SonarQube Server:  In your project‚Äôs root directory, create a sonar-project.properties file.  Configure it with your SonarQube server details.   sonar.host.url=http://your-sonarqube-server-url   sonar.login=your-auth-token   sonar.projectKey=unique-project-key3. Run Analysis:  Open a Command Prompt or PowerShell window and navigate to your project directory.  Run the following command to perform an analysis:   MSBuild.SonarQube.Runner.exe begin /k:\"your-project-key\"   MSBuild.exe   MSBuild.SonarQube.Runner.exe end4. View Results:  Visit your SonarQube server in a web browser to view the analysis results and manage your project.What Next?  With these steps, you can effectively use SonarLint for real-time code analysis within Visual Studio and integrate SonarQube for more advanced analysis, quality management, and reporting.You can consult the official SonarLint and SonarQube documentation for detailed setup and configuration instructions."
  },
  
  {
    "title": "Visual Studio Extensions for C# Developers",
    "url": "/posts/Visual-Studio-Extensions-for-C-Developers/",
    "categories": "Tips And Tricks, Visual Studio",
    "tags": "microsoft, visualstudio, tips&tricks",
    "date": "2023-07-24 00:00:00 +0200",
    





    
    "snippet": "Visual Studio extensions can significantly enhance your C# development workflow by adding features and tools that make coding, debugging, and project management more efficient. Here‚Äôs a list of ess...",
    "content": "Visual Studio extensions can significantly enhance your C# development workflow by adding features and tools that make coding, debugging, and project management more efficient. Here‚Äôs a list of essential extensions that every C# developer should consider installing.Coding Productivity      ReSharper: A powerful productivity tool that provides code analysis, quick-fixes, refactorings, and intelligent code completion.        Visual Studio IntelliCode: Utilizes AI to provide intelligent, context-aware code completion recommendations based on your coding patterns.        Visual Studio Live Share: Collaborative development tool that allows you to share your coding session with others in real-time.        CodeMaid: Helps maintain a cleaner codebase by organizing, formatting, and simplifying your code.  Debugging       OzCode: Advanced debugging tool that provides time-travel debugging, exceptional value tracking, and other debugging enhancements.        Debugger for Unity: If you‚Äôre working with Unity for game development, this extension adds debugging support for Unity projects.  Version Control  Visual Studio GitHub: Integrates GitHub with Visual Studio, providing seamless version control and code collaboration features.Code Analysis and Quality      SonarLint: A static code analysis tool that helps identify and fix code quality issues as you write your code.        Roslynator: Offers a wide range of code analyzers, refactorings, and code fixes based on the Roslyn compiler platform.  Project Management      NUnit Test Adapter: If you‚Äôre using NUnit for unit testing, this adapter allows you to run and debug NUnit tests within Visual Studio.        Visual Studio Installer Projects: Provides project templates for creating custom installation packages for your applications.        NuGet Package Manager: Manage NuGet packages directly within Visual Studio to easily add and update dependencies in your projects.  Documentation  GhostDoc: Simplifies the process of creating and maintaining code documentation by generating XML comments and helping with documentation standards.UI and Design  XAML Styler: Provides code formatting and styling for XAML markup, helping maintain clean and consistent UI code.Markdown Editing  Markdown Editor: If you‚Äôre writing documentation or READMEs in Markdown, this extension enhances the Markdown editing experience.Git Integration  Git Tools: Adds Git integration and makes it easier to manage Git repositories directly from Visual Studio.What Next?  These Visual Studio extensions can significantly improve your C# development experience. Install the ones that suit your needs and workflow to boost your productivity and code quality."
  },
  
  {
    "title": "Azure devops | Creating free account",
    "url": "/posts/Creating-free-account/",
    "categories": "Azure devops",
    "tags": "microsoft, azuredevops",
    "date": "2023-07-05 00:00:00 +0200",
    





    
    "snippet": "Create Azure devops free accountAs of my last knowledge update in January 2022, Azure DevOps Services, which provides a set of development tools, including version control, build automation, releas...",
    "content": "Create Azure devops free accountAs of my last knowledge update in January 2022, Azure DevOps Services, which provides a set of development tools, including version control, build automation, release management, and more, offers a free tier that you can use to get started. Follow below steps in order to create a free Azure DevOps account.1. Visit the Azure DevOps Services Website: Open your web browser and go to the Azure DevOps Services website at https://azure.com/devops.2. Sign Up for Azure DevOps:      Click on the ‚ÄúGet started for free‚Äù or ‚ÄúStart free‚Äù button on the homepage.        You‚Äôll be prompted to sign in with your Microsoft account (formerly known as Live ID). If you don‚Äôt have one, you can create a new Microsoft account.        Follow the sign-up process, which may include verifying your email and providing some basic information.  3. Set Up Your Organization:      Once you‚Äôve signed in, you‚Äôll need to create an organization. An organization in Azure DevOps is a way to group your projects and manage access.        Provide a unique name for your organization, and choose your region and time zone.        Click ‚ÄúContinue.‚Äù  4. Choose a Free Plan:      Azure DevOps offers a free plan that includes up to 5 users and unlimited stakeholders. You can select this free plan during the setup process.        You can also choose to start a free trial of Azure DevOps, which may include additional features beyond the free tier.  5. Configure Additional Settings:  Follow the setup wizard to configure additional settings for your organization. This may include choosing a project management process (Agile, Scrum, etc.), and you can also set up repositories, pipelines, boards, and other services.6. Start Using Azure DevOps:  After completing the setup, you‚Äôll be directed to your Azure DevOps organization. From there, you can create projects, repositories, and start managing your software development process.What Next?  Please note that while Azure DevOps offers a free tier, there may be some limitations on the number of users and resources in the free plan. Be sure to check the Azure DevOps pricing and documentation for the most up-to-date information on what‚Äôs included in the free tier.Keep in mind that the process or offerings might have changed since my last update in January 2022, so I recommend visiting the Azure DevOps website for the most current information and to set up your free account."
  },
  
  {
    "title": "C# | Best Practices",
    "url": "/posts/C-Best-Practices/",
    "categories": "Tips And Tricks, C#",
    "tags": "microsoft, csharp, c#, bestpractices, tips&tricks",
    "date": "2023-07-02 00:00:00 +0200",
    





    
    "snippet": "C# Best PracticesThese best practices are designed to help you write clean, efficient, and maintainable C# code.1. Follow Naming Conventions  Use PascalCase for class names, method names, and prope...",
    "content": "C# Best PracticesThese best practices are designed to help you write clean, efficient, and maintainable C# code.1. Follow Naming Conventions  Use PascalCase for class names, method names, and properties (e.g., MyClass, MyMethod, MyProperty).  Use camelCase for local variables and method parameters (e.g., myVariable, myParameter).  Use ALL_CAPS for constants (e.g., MY_CONSTANT).2. Use Meaningful Names  Choose descriptive and meaningful names for your variables, classes, and methods.  Avoid abbreviations and single-letter variable names unless they are widely accepted (e.g., i, j, k for loop counters).3. Organize Your Code  Use regions and comments to clearly structure your code into logical sections.  Organize your files into namespaces that reflect the functionality of your code.4. Follow the DRY Principle (Don‚Äôt Repeat Yourself)  Refactor code to eliminate duplication. If you find the same code in multiple places, create a reusable method or class.5. Use Exception Handling Wisely  Only catch exceptions when you can handle them appropriately.  Use specific exception types rather than catching Exception for better error handling.6. Use Code Documentation  Document your code using XML comments for classes, methods, and properties.  Provide clear and concise explanations of what the code does and how to use it.7. Keep Methods Small and Focused  Aim for methods that do one thing and do it well.  If a method is too long, consider breaking it into smaller, more focused methods.8. Use Dependency Injection  Favor dependency injection over hardcoding dependencies in your classes.  Use interfaces to define contracts and make your code more testable.9. Write Unit Tests  Create unit tests for your code to ensure it functions as expected.  Use a testing framework like MSTest, NUnit, or xUnit.10. Use Source Control  Use a version control system like Git to track changes to your code.  Commit and push code regularly to ensure a history of changes.11. Optimize Performance  Profile your code to identify performance bottlenecks.  Use appropriate data structures and algorithms for efficient processing.12. Keep an Eye on Security  Avoid raw SQL queries and use parameterized queries to prevent SQL injection.  Validate and sanitize user inputs to protect against security vulnerabilities.13. Follow SOLID Principles  Strive to adhere to the SOLID principles: Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion.14. Review Code  Conduct code reviews with peers to catch issues early and share knowledge.  Use code analysis tools and linters to automate code review processes.15. Stay Up-to-Date  Keep up with the latest C# features and best practices by reading blogs, books, and attending conferences.What Next?  By following these best practices, you can write C# code that is easier to read, maintain, and extend.Remember that good coding practices evolve, so always be open to learning and adapting to new techniques and tools."
  },
  
  {
    "title": "C# | Web Api's Tips and Tricks",
    "url": "/posts/C-Web-Api's-Tips-and-Tricks/",
    "categories": "Tips And Tricks, C#",
    "tags": "microsoft, csharp, c#, webapi, tips&tricks",
    "date": "2023-06-22 00:00:00 +0200",
    





    
    "snippet": "Web Api‚Äôs Tips and TricksBuilding Web APIs in C# is a powerful way to create scalable and efficient backend services. Here are some tips and tricks to help you get the most out of your C# Web API d...",
    "content": "Web Api‚Äôs Tips and TricksBuilding Web APIs in C# is a powerful way to create scalable and efficient backend services. Here are some tips and tricks to help you get the most out of your C# Web API development.1. Use ASP.NET Core  Start with ASP.NET Core for building Web APIs. It‚Äôs a cross-platform, high-performance framework with excellent support for RESTful services.2. RESTful Routes  Follow RESTful principles when designing your API endpoints. Use HTTP methods (GET, POST, PUT, DELETE) for CRUD operations and use nouns to represent resources.3. Model Validation  Leverage model validation attributes (e.g., [Required], [MaxLength], [RegularExpression]) to validate incoming data, ensuring data integrity and security.4. Versioning  Consider versioning your API from the beginning to maintain backward compatibility as your API evolves. You can use URL versioning, header versioning, or content negotiation for versioning.5. Use DTOs  Data Transfer Objects (DTOs) are essential for decoupling your API from your database models. They allow you to control what data is exposed and simplify data transformation.6. Dependency Injection  Leverage ASP.NET Core‚Äôs built-in dependency injection to manage the lifecycle of your services. This promotes loose coupling and testability.7. Middleware  ASP.NET Core middleware allows you to insert custom processing logic into the request/response pipeline. You can use it for tasks like authentication, logging, and exception handling.8. Authentication and Authorization  Implement secure authentication and authorization mechanisms, such as JWT (JSON Web Tokens) or OAuth, to protect your API endpoints.9. Pagination  For endpoints that return large datasets, implement pagination to improve performance and usability. Use query parameters like page and pageSize to control data retrieval.10. Logging and Error Handling  Set up comprehensive logging to track API usage and errors. Implement global exception handling to provide meaningful error responses to clients.11. Caching  Use response caching and distributed caching to reduce server load and improve response times for frequently accessed data.12. API Documentation  Create clear and comprehensive API documentation using tools like Swagger or OpenAPI to help clients understand how to interact with your API.13. Testing  Adopt a testing strategy that includes unit tests and integration tests to ensure the reliability and correctness of your API.14. Security  Protect your API from common security threats, such as SQL injection and cross-site scripting (XSS), by validating and sanitizing user inputs.15. Performance Optimization  Optimize your API for performance by using techniques like asynchronous programming, minimizing database queries, and reducing unnecessary data transfer.16. Rate Limiting  Implement rate limiting to prevent abuse of your API by limiting the number of requests a client can make in a given time frame.17. Continuous Integration and Deployment (CI/CD)  Set up CI/CD pipelines to automate the build, testing, and deployment of your Web API, ensuring a smooth release process."
  },
  
  {
    "title": "C# | Tips and tricks",
    "url": "/posts/C-Tips-and-tricks/",
    "categories": "Tips And Tricks, C#",
    "tags": "microsoft, csharp, c#, bestpractices, tips&tricks",
    "date": "2023-06-16 00:00:00 +0200",
    





    
    "snippet": "C# tips and tricksC# is a versatile programming language that offers many features and techniques to make your coding more efficient and maintainable. In this document, we‚Äôll explore some useful ti...",
    "content": "C# tips and tricksC# is a versatile programming language that offers many features and techniques to make your coding more efficient and maintainable. In this document, we‚Äôll explore some useful tips and tricks for C# development.1. String InterpolationString interpolation allows you to embed expressions directly within string literals. It‚Äôs a cleaner and more readable way to concatenate strings and variables.string name = \"Alice\";int age = 30;string message = $\"Hello, {name}! You are {age} years old.\";2. Null Conditional OperatorThe null-conditional operator (?.) simplifies null checks, making your code more concise and less error-prone.int? length = text?.Length;3. DeconstructionDeconstruction allows you to assign values from a tuple or an object to separate variables in a single line.var (x, y) = GetCoordinates();4. Pattern MatchingPattern matching simplifies conditional statements by checking for specific patterns in data, making your code more readable.if (obj is int number){    // Use 'number' as an int}5. Local FunctionsLocal functions are functions defined within another method, making your code more modular and improving encapsulation.int Calculate(int a, int b){    int Add(int x, int y) =&gt; x + y;    return Add(a, b);}6. LINQ (Language Integrated Query)LINQ allows for elegant and efficient querying of collections and databases.var result = from person in people             where person.Age &gt; 30             select person.Name;7. Ternary OperatorThe ternary operator is a concise way to write simple conditional expressions.string result = (condition) ? \"True\" : \"False\";8. Using StatementThe using statement simplifies resource management, ensuring that disposable objects are properly disposed of when no longer needed.using (var stream = new FileStream(\"file.txt\", FileMode.Open)){    // Work with the file stream}9. Async/AwaitAsync and await make asynchronous programming more readable and maintainable.async Task&lt;string&gt; DownloadAsync(string url){    var data = await DownloadDataAsync(url);    return Encoding.UTF8.GetString(data);}10. Extension MethodsYou can add new methods to existing types using extension methods, enhancing code reusability.public static class StringExtensions{    public static bool IsNullOrEmpty(this string value)    {        return string.IsNullOrEmpty(value);    }}What Next?  These are just a few of the many tips and tricks that can help you become a more proficient C# developer. As you continue to work with C#, explore its vast ecosystem to improve your skills and productivity."
  }
  
]

